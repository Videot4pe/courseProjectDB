{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar v1 = _interopRequireWildcard(require(\"./packstream-v1\"));\n\nvar _spatialTypes = require(\"../spatial-types\");\n\nvar _temporalTypes = require(\"../temporal-types\");\n\nvar _integer = require(\"../integer\");\n\nvar _temporalUtil = require(\"../internal/temporal-util\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nvar Packer =\n/*#__PURE__*/\nfunction (_v1$Packer) {\n  (0, _inherits2[\"default\"])(Packer, _v1$Packer);\n\n  function Packer() {\n    (0, _classCallCheck2[\"default\"])(this, Packer);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Packer).apply(this, arguments));\n  }\n\n  (0, _createClass2[\"default\"])(Packer, [{\n    key: \"disableByteArrays\",\n    value: function disableByteArrays() {\n      throw new Error('Bolt V2 should always support byte arrays');\n    }\n  }, {\n    key: \"packable\",\n    value: function packable(obj, onError) {\n      var _this = this;\n\n      if ((0, _spatialTypes.isPoint)(obj)) {\n        return function () {\n          return packPoint(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isDuration)(obj)) {\n        return function () {\n          return packDuration(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isLocalTime)(obj)) {\n        return function () {\n          return packLocalTime(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isTime)(obj)) {\n        return function () {\n          return packTime(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isDate)(obj)) {\n        return function () {\n          return packDate(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {\n        return function () {\n          return packLocalDateTime(obj, _this, onError);\n        };\n      } else if ((0, _temporalTypes.isDateTime)(obj)) {\n        return function () {\n          return packDateTime(obj, _this, onError);\n        };\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Packer.prototype), \"packable\", this).call(this, obj, onError);\n      }\n    }\n  }]);\n  return Packer;\n}(v1.Packer);\n\nexports.Packer = Packer;\n\nvar Unpacker =\n/*#__PURE__*/\nfunction (_v1$Unpacker) {\n  (0, _inherits2[\"default\"])(Unpacker, _v1$Unpacker);\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   */\n\n  function Unpacker() {\n    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    (0, _classCallCheck2[\"default\"])(this, Unpacker);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Unpacker).call(this, disableLosslessIntegers));\n  }\n\n  (0, _createClass2[\"default\"])(Unpacker, [{\n    key: \"_unpackUnknownStruct\",\n    value: function _unpackUnknownStruct(signature, structSize, buffer) {\n      if (signature === POINT_2D) {\n        return unpackPoint2D(this, structSize, buffer);\n      } else if (signature === POINT_3D) {\n        return unpackPoint3D(this, structSize, buffer);\n      } else if (signature === DURATION) {\n        return unpackDuration(this, structSize, buffer);\n      } else if (signature === LOCAL_TIME) {\n        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === TIME) {\n        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE) {\n        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === LOCAL_DATE_TIME) {\n        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);\n      } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);\n      } else {\n        return (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(Unpacker.prototype), \"_unpackUnknownStruct\", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);\n      }\n    }\n  }]);\n  return Unpacker;\n}(v1.Unpacker);\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nexports.Unpacker = Unpacker;\n\nfunction packPoint(point, packer, onError) {\n  var is2DPoint = point.z === null || point.z === undefined;\n\n  if (is2DPoint) {\n    packPoint2D(point, packer, onError);\n  } else {\n    packPoint3D(point, packer, onError);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packPoint2D(point, packer, onError) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid), onError), packer.packable(point.x, onError), packer.packable(point.y, onError)];\n  packer.packStruct(POINT_2D, packableStructFields, onError);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packPoint3D(point, packer, onError) {\n  var packableStructFields = [packer.packable((0, _integer[\"int\"])(point.srid), onError), packer.packable(point.x, onError), packer.packable(point.y, onError), packer.packable(point.z, onError)];\n  packer.packStruct(POINT_3D, packableStructFields, onError);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\n\n\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\n\n\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n\n  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packDuration(value, packer, onError) {\n  var months = (0, _integer[\"int\"])(value.months);\n  var days = (0, _integer[\"int\"])(value.days);\n  var seconds = (0, _integer[\"int\"])(value.seconds);\n  var nanoseconds = (0, _integer[\"int\"])(value.nanoseconds);\n  var packableStructFields = [packer.packable(months, onError), packer.packable(days, onError), packer.packable(seconds, onError), packer.packable(nanoseconds, onError)];\n  packer.packStruct(DURATION, packableStructFields, onError);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\n\n\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packLocalTime(value, packer, onError) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay, onError)];\n  packer.packStruct(LOCAL_TIME, packableStructFields, onError);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\n\n\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packTime(value, packer, onError) {\n  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay, onError), packer.packable(offsetSeconds, onError)];\n  packer.packStruct(TIME, packableStructFields, onError);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\n\n\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packDate(value, packer, onError) {\n  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay, onError)];\n  packer.packStruct(DATE, packableStructFields, onError);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\n\n\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packLocalDateTime(value, packer, onError) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond, onError), packer.packable(nano, onError)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields, onError);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\n\n\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packDateTime(value, packer, onError) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer, onError);\n  } else {\n    packDateTimeWithZoneOffset(value, packer, onError);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packDateTimeWithZoneOffset(value, packer, onError) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, _integer[\"int\"])(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond, onError), packer.packable(nano, onError), packer.packable(timeZoneOffsetSeconds, onError)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields, onError);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\n\n\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n * @param {function} onError the error callback.\n */\n\n\nfunction packDateTimeWithZoneId(value, packer, onError) {\n  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, _integer[\"int\"])(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond, onError), packer.packable(nano, onError), packer.packable(timeZoneId, onError)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields, onError);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\n\n\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {\n  if (!disableLosslessIntegers) {\n    return obj;\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}","map":null,"metadata":{},"sourceType":"script"}