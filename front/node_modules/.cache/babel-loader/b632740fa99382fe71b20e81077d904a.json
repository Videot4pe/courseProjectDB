{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _streamObserver = _interopRequireDefault(require(\"./internal/stream-observer\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _error = require(\"./error\");\n\nvar _util = require(\"./internal/util\");\n\nvar _connectionHolder = _interopRequireDefault(require(\"./internal/connection-holder\"));\n\nvar _driver = _interopRequireDefault(require(\"./driver\"));\n\nvar _constants = require(\"./internal/constants\");\n\nvar _transactionExecutor = _interopRequireDefault(require(\"./internal/transaction-executor\"));\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Typedef for JSDoc. Declares TransactionConfig type and makes it possible to use in in method-level docs.\n\n/**\n * Configuration object containing settings for explicit and auto-commit transactions.\n * <p>\n * Configuration is supported for:\n * <ul>\n *   <li>queries executed in auto-commit transactions using {@link Session#run}</li>\n *   <li>transactions started by transaction functions using {@link Session#readTransaction} and {@link Session#writeTransaction}</li>\n *   <li>explicit transactions using {@link Session#beginTransaction}</li>\n * </ul>\n * @typedef {object} TransactionConfig\n * @property {number} timeout - the transaction timeout in **milliseconds**. Transactions that execute longer than the configured timeout will\n * be terminated by the database. This functionality allows to limit query/transaction execution time. Specified timeout overrides the default timeout\n * configured in the database using `dbms.transaction.timeout` setting. Value should not represent a duration of zero or negative duration.\n * @property {object} metadata - the transaction metadata. Specified metadata will be attached to the executing transaction and visible in the output of\n * `dbms.listQueries` and `dbms.listTransactions` procedures. It will also get logged to the `query.log`. This functionality makes it easier to tag\n * transactions and is equivalent to `dbms.setTXMetaData` procedure.\n */\n\n/**\n * A Session instance is used for handling the connection and\n * sending statements through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\n\n\nvar Session =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {string} mode the default access mode for this session.\n   * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.\n   * @param {Bookmark} bookmark - the initial bookmark for this session.\n   * @param {Object} [config={}] - this driver configuration.\n   */\n  function Session(mode, connectionProvider, bookmark, config) {\n    (0, _classCallCheck2[\"default\"])(this, Session);\n    this._mode = mode;\n    this._readConnectionHolder = new _connectionHolder[\"default\"](_constants.ACCESS_MODE_READ, connectionProvider);\n    this._writeConnectionHolder = new _connectionHolder[\"default\"](_constants.ACCESS_MODE_WRITE, connectionProvider);\n    this._open = true;\n    this._hasTx = false;\n    this._lastBookmark = bookmark;\n    this._transactionExecutor = _createTransactionExecutor(config);\n  }\n  /**\n   * Run Cypher statement\n   * Could be called with a statement object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the statement and parameters as separate arguments.\n   * @param {mixed} statement - Cypher statement to execute\n   * @param {Object} parameters - Map with parameters to use in statement\n   * @param {TransactionConfig} [transactionConfig] - configuration for the new auto-commit transaction.\n   * @return {Result} - New Result\n   */\n\n\n  (0, _createClass2[\"default\"])(Session, [{\n    key: \"run\",\n    value: function run(statement, parameters, transactionConfig) {\n      var _this = this;\n\n      var _validateStatementAnd = (0, _util.validateStatementAndParameters)(statement, parameters),\n          query = _validateStatementAnd.query,\n          params = _validateStatementAnd.params;\n\n      var autoCommitTxConfig = transactionConfig ? new _txConfig[\"default\"](transactionConfig) : _txConfig[\"default\"].empty();\n      return this._run(query, params, function (connection, streamObserver) {\n        return connection.protocol().run(query, params, _this._lastBookmark, autoCommitTxConfig, _this._mode, streamObserver);\n      });\n    }\n  }, {\n    key: \"_run\",\n    value: function _run(statement, parameters, statementRunner) {\n      var streamObserver = new SessionStreamObserver(this);\n\n      var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n      if (!this._hasTx) {\n        connectionHolder.initializeConnection();\n        connectionHolder.getConnection(streamObserver).then(function (connection) {\n          return statementRunner(connection, streamObserver);\n        })[\"catch\"](function (error) {\n          return streamObserver.onError(error);\n        });\n      } else {\n        streamObserver.onError((0, _error.newError)('Statements cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n      }\n\n      return new _result[\"default\"](streamObserver, statement, parameters, function () {\n        return streamObserver.serverMetadata();\n      }, connectionHolder);\n    }\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run statements outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - configuration for the new auto-commit transaction.\n     * @returns {Transaction} - New Transaction\n     */\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(transactionConfig) {\n      // this function needs to support bookmarks parameter for backwards compatibility\n      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n      // that's why we need to check parameter type and decide how to interpret the value\n      var arg = transactionConfig;\n\n      var txConfig = _txConfig[\"default\"].empty();\n\n      if (typeof arg === 'string' || arg instanceof String || Array.isArray(arg)) {\n        // argument looks like a single or multiple bookmarks\n        // bookmarks in this function are deprecated but need to be supported for backwards compatibility\n        this._updateBookmark(new _bookmark[\"default\"](arg));\n      } else if (arg) {\n        // argument is probably a transaction configuration\n        txConfig = new _txConfig[\"default\"](arg);\n      }\n\n      return this._beginTransaction(this._mode, txConfig);\n    }\n  }, {\n    key: \"_beginTransaction\",\n    value: function _beginTransaction(accessMode, txConfig) {\n      if (this._hasTx) {\n        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n      }\n\n      var mode = _driver[\"default\"]._validateSessionMode(accessMode);\n\n      var connectionHolder = this._connectionHolderWithMode(mode);\n\n      connectionHolder.initializeConnection();\n      this._hasTx = true;\n      var tx = new _transaction[\"default\"](connectionHolder, this._transactionClosed.bind(this), this._updateBookmark.bind(this));\n\n      tx._begin(this._lastBookmark, txConfig);\n\n      return tx;\n    }\n  }, {\n    key: \"_transactionClosed\",\n    value: function _transactionClosed() {\n      this._hasTx = false;\n    }\n    /**\n     * Return the bookmark received following the last completed {@link Transaction}.\n     *\n     * @return {string|null} a reference to a previous transaction\n     */\n\n  }, {\n    key: \"lastBookmark\",\n    value: function lastBookmark() {\n      return this._lastBookmark.maxBookmarkAsString();\n    }\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - configuration for all transactions started to execute the unit of work.\n     * @return {Promise} resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"readTransaction\",\n    value: function readTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);\n    }\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - configuration for all transactions started to execute the unit of work.\n     * @return {Promise} resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n\n  }, {\n    key: \"writeTransaction\",\n    value: function writeTransaction(transactionWork, transactionConfig) {\n      var config = new _txConfig[\"default\"](transactionConfig);\n      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {\n      var _this2 = this;\n\n      return this._transactionExecutor.execute(function () {\n        return _this2._beginTransaction(accessMode, transactionConfig);\n      }, transactionWork);\n    }\n    /**\n     * Update value of the last bookmark.\n     * @param {Bookmark} newBookmark the new bookmark.\n     */\n\n  }, {\n    key: \"_updateBookmark\",\n    value: function _updateBookmark(newBookmark) {\n      if (newBookmark && !newBookmark.isEmpty()) {\n        this._lastBookmark = newBookmark;\n      }\n    }\n    /**\n     * Close this session.\n     * @param {function()} callback - Function to be called after the session has been closed\n     * @return\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this3 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return null;\n      };\n\n      if (this._open) {\n        this._open = false;\n\n        this._transactionExecutor.close();\n\n        this._readConnectionHolder.close().then(function () {\n          _this3._writeConnectionHolder.close().then(function () {\n            callback();\n          });\n        });\n      } else {\n        callback();\n      }\n    }\n  }, {\n    key: \"_connectionHolderWithMode\",\n    value: function _connectionHolderWithMode(mode) {\n      if (mode === _constants.ACCESS_MODE_READ) {\n        return this._readConnectionHolder;\n      } else if (mode === _constants.ACCESS_MODE_WRITE) {\n        return this._writeConnectionHolder;\n      } else {\n        throw (0, _error.newError)('Unknown access mode: ' + mode);\n      }\n    }\n  }]);\n  return Session;\n}();\n/**\n * @private\n */\n\n\nvar SessionStreamObserver =\n/*#__PURE__*/\nfunction (_StreamObserver) {\n  (0, _inherits2[\"default\"])(SessionStreamObserver, _StreamObserver);\n\n  function SessionStreamObserver(session) {\n    var _this4;\n\n    (0, _classCallCheck2[\"default\"])(this, SessionStreamObserver);\n    _this4 = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(SessionStreamObserver).call(this));\n    _this4._session = session;\n    return _this4;\n  }\n\n  (0, _createClass2[\"default\"])(SessionStreamObserver, [{\n    key: \"onCompleted\",\n    value: function onCompleted(meta) {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(SessionStreamObserver.prototype), \"onCompleted\", this).call(this, meta);\n      var bookmark = new _bookmark[\"default\"](meta.bookmark);\n\n      this._session._updateBookmark(bookmark);\n    }\n  }]);\n  return SessionStreamObserver;\n}(_streamObserver[\"default\"]);\n\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new _transactionExecutor[\"default\"](maxRetryTimeMs);\n}\n\nvar _default = Session;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}