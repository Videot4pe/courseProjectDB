{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _streamObserver = _interopRequireDefault(require(\"./internal/stream-observer\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _util = require(\"./internal/util\");\n\nvar _connectionHolder = require(\"./internal/connection-holder\");\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\n\n\nvar Transaction =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\n   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\n   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\n   */\n  function Transaction(connectionHolder, onClose, onBookmark) {\n    (0, _classCallCheck2[\"default\"])(this, Transaction);\n    this._connectionHolder = connectionHolder;\n    this._state = _states.ACTIVE;\n    this._onClose = onClose;\n    this._onBookmark = onBookmark;\n  }\n\n  (0, _createClass2[\"default\"])(Transaction, [{\n    key: \"_begin\",\n    value: function _begin(bookmark, txConfig) {\n      var _this = this;\n\n      var streamObserver = new _TransactionStreamObserver(this);\n\n      this._connectionHolder.getConnection(streamObserver).then(function (conn) {\n        return conn.protocol().beginTransaction(bookmark, txConfig, _this._connectionHolder.mode(), streamObserver);\n      })[\"catch\"](function (error) {\n        return streamObserver.onError(error);\n      });\n    }\n    /**\n     * Run Cypher statement\n     * Could be called with a statement object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the statement and parameters as separate arguments.\n     * @param {mixed} statement - Cypher statement to execute\n     * @param {Object} parameters - Map with parameters to use in statement\n     * @return {Result} New Result\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(statement, parameters) {\n      var _validateStatementAnd = (0, _util.validateStatementAndParameters)(statement, parameters),\n          query = _validateStatementAnd.query,\n          params = _validateStatementAnd.params;\n\n      return this._state.run(this._connectionHolder, new _TransactionStreamObserver(this), query, params);\n    }\n    /**\n     * Commits the transaction and returns the result.\n     *\n     * After committing the transaction can no longer be used.\n     *\n     * @returns {Result} New Result\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var committed = this._state.commit(this._connectionHolder, new _TransactionStreamObserver(this));\n\n      this._state = committed.state; // clean up\n\n      this._onClose();\n\n      return committed.result;\n    }\n    /**\n     * Rollbacks the transaction.\n     *\n     * After rolling back, the transaction can no longer be used.\n     *\n     * @returns {Result} New Result\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var committed = this._state.rollback(this._connectionHolder, new _TransactionStreamObserver(this));\n\n      this._state = committed.state; // clean up\n\n      this._onClose();\n\n      return committed.result;\n    }\n    /**\n     * Check if this transaction is active, which means commit and rollback did not happen.\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n     */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this._state === _states.ACTIVE;\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError() {\n      // error will be \"acknowledged\" by sending a RESET message\n      // database will then forget about this transaction and cleanup all corresponding resources\n      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n      this._state = _states.FAILED;\n\n      this._onClose(); // release connection back to the pool\n\n\n      return this._connectionHolder.releaseConnection();\n    }\n  }]);\n  return Transaction;\n}();\n/** Internal stream observer used for transactional results */\n\n\nvar _TransactionStreamObserver =\n/*#__PURE__*/\nfunction (_StreamObserver) {\n  (0, _inherits2[\"default\"])(_TransactionStreamObserver, _StreamObserver);\n\n  function _TransactionStreamObserver(tx) {\n    var _this2;\n\n    (0, _classCallCheck2[\"default\"])(this, _TransactionStreamObserver);\n    _this2 = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(_TransactionStreamObserver).call(this));\n    _this2._tx = tx;\n    return _this2;\n  }\n\n  (0, _createClass2[\"default\"])(_TransactionStreamObserver, [{\n    key: \"onError\",\n    value: function onError(error) {\n      var _this3 = this;\n\n      if (!this._hasFailed) {\n        this._tx._onError().then(function () {\n          (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(_TransactionStreamObserver.prototype), \"onError\", _this3).call(_this3, error);\n        });\n      }\n    }\n  }, {\n    key: \"onCompleted\",\n    value: function onCompleted(meta) {\n      (0, _get2[\"default\"])((0, _getPrototypeOf2[\"default\"])(_TransactionStreamObserver.prototype), \"onCompleted\", this).call(this, meta);\n      var bookmark = new _bookmark[\"default\"](meta.bookmark);\n\n      this._tx._onBookmark(bookmark);\n    }\n  }]);\n  return _TransactionStreamObserver;\n}(_streamObserver[\"default\"]);\n/** internal state machine of the transaction */\n\n\nvar _states = {\n  // The transaction is running with no explicit success or failure marked\n  ACTIVE: {\n    commit: function commit(connectionHolder, observer) {\n      return {\n        result: finishTransaction(true, connectionHolder, observer),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function rollback(connectionHolder, observer) {\n      return {\n        result: finishTransaction(false, connectionHolder, observer),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(connectionHolder, observer, statement, parameters) {\n      // RUN in explicit transaction can't contain bookmarks and transaction configuration\n      var bookmark = _bookmark[\"default\"].empty();\n\n      var txConfig = _txConfig[\"default\"].empty();\n\n      connectionHolder.getConnection(observer).then(function (conn) {\n        return conn.protocol().run(statement, parameters, bookmark, txConfig, connectionHolder.mode(), observer);\n      })[\"catch\"](function (error) {\n        return observer.onError(error);\n      });\n      return _newRunResult(observer, statement, parameters, function () {\n        return observer.serverMetadata();\n      });\n    }\n  },\n  // An error has occurred, transaction can no longer be used and no more messages will\n  // be sent for this transaction.\n  FAILED: {\n    commit: function commit(connectionHolder, observer) {\n      observer.onError({\n        error: 'Cannot commit statements in this transaction, because previous statements in the ' + 'transaction has failed and the transaction has been rolled back. Please start a new' + ' transaction to run another statement.'\n      });\n      return {\n        result: _newDummyResult(observer, 'COMMIT', {}),\n        state: _states.FAILED\n      };\n    },\n    rollback: function rollback(connectionHolder, observer) {\n      observer.markCompleted();\n      return {\n        result: _newDummyResult(observer, 'ROLLBACK', {}),\n        state: _states.FAILED\n      };\n    },\n    run: function run(connectionHolder, observer, statement, parameters) {\n      observer.onError({\n        error: 'Cannot run statement, because previous statements in the ' + 'transaction has failed and the transaction has already been rolled back.'\n      });\n      return _newDummyResult(observer, statement, parameters);\n    }\n  },\n  // This transaction has successfully committed\n  SUCCEEDED: {\n    commit: function commit(connectionHolder, observer) {\n      observer.onError({\n        error: 'Cannot commit statements in this transaction, because commit has already been successfully called on the transaction and transaction has been closed. Please start a new' + ' transaction to run another statement.'\n      });\n      return {\n        result: _newDummyResult(observer, 'COMMIT', {}),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function rollback(connectionHolder, observer) {\n      observer.onError({\n        error: 'Cannot rollback transaction, because transaction has already been successfully closed.'\n      });\n      return {\n        result: _newDummyResult(observer, 'ROLLBACK', {}),\n        state: _states.SUCCEEDED\n      };\n    },\n    run: function run(connectionHolder, observer, statement, parameters) {\n      observer.onError({\n        error: 'Cannot run statement, because transaction has already been successfully closed.'\n      });\n      return _newDummyResult(observer, statement, parameters);\n    }\n  },\n  // This transaction has been rolled back\n  ROLLED_BACK: {\n    commit: function commit(connectionHolder, observer) {\n      observer.onError({\n        error: 'Cannot commit this transaction, because it has already been rolled back.'\n      });\n      return {\n        result: _newDummyResult(observer, 'COMMIT', {}),\n        state: _states.ROLLED_BACK\n      };\n    },\n    rollback: function rollback(connectionHolder, observer) {\n      observer.onError({\n        error: 'Cannot rollback transaction, because transaction has already been rolled back.'\n      });\n      return {\n        result: _newDummyResult(observer, 'ROLLBACK', {}),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(connectionHolder, observer, statement, parameters) {\n      observer.onError({\n        error: 'Cannot run statement, because transaction has already been rolled back.'\n      });\n      return _newDummyResult(observer, statement, parameters);\n    }\n  }\n};\n\nfunction finishTransaction(commit, connectionHolder, observer) {\n  connectionHolder.getConnection(observer).then(function (connection) {\n    if (commit) {\n      return connection.protocol().commitTransaction(observer);\n    } else {\n      return connection.protocol().rollbackTransaction(observer);\n    }\n  })[\"catch\"](function (error) {\n    return observer.onError(error);\n  }); // for commit & rollback we need result that uses real connection holder and notifies it when\n  // connection is not needed and can be safely released to the pool\n\n  return new _result[\"default\"](observer, commit ? 'COMMIT' : 'ROLLBACK', {}, emptyMetadataSupplier, connectionHolder);\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * Should be used as a result for running cypher statements. They can result in metadata but should not\n * influence real connection holder to release connections because single transaction can have\n * {@link Transaction#run} called multiple times.\n * @param {StreamObserver} observer - an observer for the created result.\n * @param {string} statement - the cypher statement that produced the result.\n * @param {object} parameters - the parameters for cypher statement that produced the result.\n * @param {function} metadataSupplier - the function that returns a metadata object.\n * @return {Result} new result.\n * @private\n */\n\n\nfunction _newRunResult(observer, statement, parameters, metadataSupplier) {\n  return new _result[\"default\"](observer, statement, parameters, metadataSupplier, _connectionHolder.EMPTY_CONNECTION_HOLDER);\n}\n/**\n * Creates a {@link Result} without metadata supplier and with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {StreamObserver} observer - an observer for the created result.\n * @param {string} statement - the cypher statement that produced the result.\n * @param {object} parameters - the parameters for cypher statement that produced the result.\n * @return {Result} new result.\n * @private\n */\n\n\nfunction _newDummyResult(observer, statement, parameters) {\n  return new _result[\"default\"](observer, statement, parameters, emptyMetadataSupplier, _connectionHolder.EMPTY_CONNECTION_HOLDER);\n}\n\nfunction emptyMetadataSupplier() {\n  return {};\n}\n\nvar _default = Transaction;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}