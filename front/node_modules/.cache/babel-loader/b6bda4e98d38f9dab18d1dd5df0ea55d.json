{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.driver = driver;\nObject.defineProperty(exports, \"int\", {\n  enumerable: true,\n  get: function get() {\n    return _integer[\"int\"];\n  }\n});\nObject.defineProperty(exports, \"isInt\", {\n  enumerable: true,\n  get: function get() {\n    return _integer.isInt;\n  }\n});\nObject.defineProperty(exports, \"Neo4jError\", {\n  enumerable: true,\n  get: function get() {\n    return _error.Neo4jError;\n  }\n});\nObject.defineProperty(exports, \"isPoint\", {\n  enumerable: true,\n  get: function get() {\n    return _spatialTypes.isPoint;\n  }\n});\nObject.defineProperty(exports, \"isDate\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isDate;\n  }\n});\nObject.defineProperty(exports, \"isDateTime\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isDateTime;\n  }\n});\nObject.defineProperty(exports, \"isDuration\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isDuration;\n  }\n});\nObject.defineProperty(exports, \"isLocalDateTime\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isLocalDateTime;\n  }\n});\nObject.defineProperty(exports, \"isLocalTime\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isLocalTime;\n  }\n});\nObject.defineProperty(exports, \"isTime\", {\n  enumerable: true,\n  get: function get() {\n    return _temporalTypes.isTime;\n  }\n});\nexports[\"default\"] = exports.temporal = exports.spatial = exports.error = exports.session = exports.types = exports.logging = exports.auth = exports.integer = void 0;\n\nvar _integer = _interopRequireWildcard(require(\"./integer\"));\n\nvar _graphTypes = require(\"./graph-types\");\n\nvar _error = require(\"./error\");\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _resultSummary = _interopRequireDefault(require(\"./result-summary\"));\n\nvar _record = _interopRequireDefault(require(\"./record\"));\n\nvar _driver = require(\"./driver\");\n\nvar _routingDriver = _interopRequireDefault(require(\"./routing-driver\"));\n\nvar _version = _interopRequireDefault(require(\"../version\"));\n\nvar _util = require(\"./internal/util\");\n\nvar _urlUtil = _interopRequireDefault(require(\"./internal/url-util\"));\n\nvar _httpDriver = _interopRequireDefault(require(\"./internal/http/http-driver\"));\n\nvar _spatialTypes = require(\"./spatial-types\");\n\nvar _temporalTypes = require(\"./temporal-types\");\n\nvar _serverAddress = _interopRequireDefault(require(\"./internal/server-address\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @property {function(username: string, password: string, realm: ?string)} basic the function to create a\n * basic authentication token.\n * @property {function(base64EncodedTicket: string)} kerberos the function to create a Kerberos authentication token.\n * Accepts a single string argument - base64 encoded Kerberos ticket.\n * @property {function(principal: string, credentials: string, realm: string, scheme: string, parameters: ?object)} custom\n * the function to create a custom authentication token.\n */\n\n\nvar auth = {\n  basic: function basic(username, password) {\n    var realm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n    if (realm) {\n      return {\n        scheme: 'basic',\n        principal: username,\n        credentials: password,\n        realm: realm\n      };\n    } else {\n      return {\n        scheme: 'basic',\n        principal: username,\n        credentials: password\n      };\n    }\n  },\n  kerberos: function kerberos(base64EncodedTicket) {\n    return {\n      scheme: 'kerberos',\n      principal: '',\n      // This empty string is required for backwards compatibility.\n      credentials: base64EncodedTicket\n    };\n  },\n  custom: function custom(principal, credentials, realm, scheme) {\n    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n\n    if (parameters) {\n      return {\n        scheme: scheme,\n        principal: principal,\n        credentials: credentials,\n        realm: realm,\n        parameters: parameters\n      };\n    } else {\n      return {\n        scheme: scheme,\n        principal: principal,\n        credentials: credentials,\n        realm: realm\n      };\n    }\n  }\n};\nexports.auth = auth;\nvar USER_AGENT = 'neo4j-javascript/' + _version[\"default\"];\n/**\n * Object containing predefined logging configurations. These are expected to be used as values of the driver config's `logging` property.\n * @property {function(level: ?string): object} console the function to create a logging config that prints all messages to `console.log` with\n * timestamp, level and message. It takes an optional `level` parameter which represents the maximum log level to be logged. Default value is 'info'.\n */\n\nvar logging = {\n  console: function (_console) {\n    function console(_x) {\n      return _console.apply(this, arguments);\n    }\n\n    console.toString = function () {\n      return _console.toString();\n    };\n\n    return console;\n  }(function (level) {\n    return {\n      level: level,\n      logger: function logger(level, message) {\n        return console.log(\"\".concat(global.Date.now(), \" \").concat(level.toUpperCase(), \" \").concat(message));\n      }\n    };\n  })\n  /**\n   * Construct a new Neo4j Driver. This is your main entry point for this\n   * library.\n   *\n   * ## Configuration\n   *\n   * This function optionally takes a configuration argument. Available configuration\n   * options are as follows:\n   *\n   *     {\n   *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.\n   *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF\n   *\n   *       // Trust strategy to use if encryption is enabled. There is no mode to disable\n   *       // trust other than disabling encryption altogether. The reason for\n   *       // this is that if you don't know who you are talking to, it is easy for an\n   *       // attacker to hijack your encrypted connection, rendering encryption pointless.\n   *       //\n   *       // TRUST_ALL_CERTIFICATES is the default choice for NodeJS deployments. It only requires\n   *       // new host to provide a certificate and does no verification of the provided certificate.\n   *       //\n   *       // TRUST_ON_FIRST_USE is available for modern NodeJS deployments, and works\n   *       // similarly to how `ssl` works - the first time we connect to a new host,\n   *       // we remember the certificate they use. If the certificate ever changes, we\n   *       // assume it is an attempt to hijack the connection and require manual intervention.\n   *       // This means that by default, connections \"just work\" while still giving you\n   *       // good encrypted protection.\n   *       //\n   *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is the classic approach to trust verification -\n   *       // whenever we establish an encrypted connection, we ensure the host is using\n   *       // an encryption certificate that is in, or is signed by, a certificate listed\n   *       // as trusted. In the web bundle, this list of trusted certificates is maintained\n   *       // by the web browser. In NodeJS, you configure the list with the next config option.\n   *       //\n   *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES means that you trust whatever certificates\n   *       // are in the default certificate chain of th\n   *       trust: \"TRUST_ALL_CERTIFICATES\" | \"TRUST_ON_FIRST_USE\" | \"TRUST_SIGNED_CERTIFICATES\" |\n   *       \"TRUST_CUSTOM_CA_SIGNED_CERTIFICATES\" | \"TRUST_SYSTEM_CA_SIGNED_CERTIFICATES\",\n   *\n   *       // List of one or more paths to trusted encryption certificates. This only\n   *       // works in the NodeJS bundle, and only matters if you use \"TRUST_CUSTOM_CA_SIGNED_CERTIFICATES\".\n   *       // The certificate files should be in regular X.509 PEM format.\n   *       // For instance, ['./trusted.pem']\n   *       trustedCertificates: [],\n   *\n   *       // Path to a file where the driver saves hosts it has seen in the past, this is\n   *       // very similar to the ssl tool's known_hosts file. Each time we connect to a\n   *       // new host, a hash of their certificate is stored along with the domain name and\n   *       // port, and this is then used to verify the host certificate does not change.\n   *       // This setting has no effect unless TRUST_ON_FIRST_USE is enabled.\n   *       knownHosts:\"~/.neo4j/known_hosts\",\n   *\n   *       // The max number of connections that are allowed idle in the pool at any time.\n   *       // Connection will be destroyed if this threshold is exceeded.\n   *       // **Deprecated:** please use `maxConnectionPoolSize` instead.\n   *       connectionPoolSize: 100,\n   *\n   *       // The maximum total number of connections allowed to be managed by the connection pool, per host.\n   *       // This includes both in-use and idle connections. No maximum connection pool size is imposed\n   *       // by default.\n   *       maxConnectionPoolSize: 100,\n   *\n   *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this\n   *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition\n   *       // so that new session is never backed by an old connection. Setting this option to a low value will cause\n   *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime\n   *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,\n   *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero\n   *       // and negative values result in lifetime not being checked.\n   *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour\n   *\n   *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new\n   *       // connection or borrow an existing one.\n   *       connectionAcquisitionTimeout: 60000, // 1 minute\n   *\n   *       // Specify the maximum time in milliseconds transactions are allowed to retry via\n   *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.\n   *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient\n   *       // errors with exponential backoff using initial delay of 1 second.\n   *       // Default value is 30000 which is 30 seconds.\n   *       maxTransactionRetryTime: 30000, // 30 seconds\n   *\n   *       // Provide an alternative load balancing strategy for the routing driver to use.\n   *       // Driver uses \"least_connected\" by default.\n   *       // **Note:** We are experimenting with different strategies. This could be removed in the next minor\n   *       // version.\n   *       loadBalancingStrategy: \"least_connected\" | \"round_robin\",\n   *\n   *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values\n   *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured\n   *       // on the operating system level. Default value is 30000, which is 30 seconds.\n   *       connectionTimeout: 30000, // 30 seconds\n   *\n   *       // Make this driver always return native JavaScript numbers for integer values, instead of the\n   *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as\n   *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.\n   *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones\n   *       // interacting with the database. Stored numbers might in such case be not representable by native\n   *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was\n   *       // initially imported using neo4j import tool and contained numbers larger than\n   *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.\n   *       // Default value for this option is `false` because native JavaScript numbers might result\n   *       // in loss of precision in the general case.\n   *       disableLosslessIntegers: false,\n   *\n   *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.\n   *       //\n   *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and\n   *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all\n   *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.\n   *       //\n   *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should\n   *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations\n   *       // because it is often executed on a hot path.\n   *       //\n   *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.\n   *       logging: {\n   *         level: 'info',\n   *         logger: (level, message) => console.log(level + ' ' + message)\n   *       },\n   *\n   *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.\n   *       // Such resolution happens:\n   *       //  * during the very first rediscovery when driver is created\n   *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address\n   *       //\n   *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.\n   *       // In browser environment driver uses the initial address as-is.\n   *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.\n   *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses\n   *       // or array of addresses directly.\n   *       resolver: function(address) {\n   *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];\n   *       },\n   *     }\n   *\n   * @param {string} url The URL for the Neo4j database, for instance \"bolt://localhost\"\n   * @param {Map<String,String>} authToken Authentication credentials. See {@link auth} for helpers.\n   * @param {Object} config Configuration object. See the configuration section above for details.\n   * @returns {Driver}\n   */\n\n};\nexports.logging = logging;\n\nfunction driver(url, authToken) {\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0, _util.assertString)(url, 'Bolt URL');\n\n  var parsedUrl = _urlUtil[\"default\"].parseDatabaseUrl(url);\n\n  if (['bolt+routing', 'neo4j'].indexOf(parsedUrl.scheme) !== -1) {\n    return new _routingDriver[\"default\"](_serverAddress[\"default\"].fromUrl(parsedUrl.hostAndPort), parsedUrl.query, USER_AGENT, authToken, config);\n  } else if (parsedUrl.scheme === 'bolt') {\n    if (!(0, _util.isEmptyObjectOrNull)(parsedUrl.query)) {\n      throw new Error(\"Parameters are not supported with scheme 'bolt'. Given URL: '\".concat(url, \"'\"));\n    }\n\n    return new _driver.Driver(_serverAddress[\"default\"].fromUrl(parsedUrl.hostAndPort), USER_AGENT, authToken, config);\n  } else if (parsedUrl.scheme === 'http' || parsedUrl.scheme === 'https') {\n    return new _httpDriver[\"default\"](parsedUrl, USER_AGENT, authToken, config);\n  } else {\n    throw new Error(\"Unknown scheme: \".concat(parsedUrl.scheme));\n  }\n}\n/**\n * Object containing constructors for all neo4j types.\n */\n\n\nvar types = {\n  Node: _graphTypes.Node,\n  Relationship: _graphTypes.Relationship,\n  UnboundRelationship: _graphTypes.UnboundRelationship,\n  PathSegment: _graphTypes.PathSegment,\n  Path: _graphTypes.Path,\n  Result: _result[\"default\"],\n  ResultSummary: _resultSummary[\"default\"],\n  Record: _record[\"default\"],\n  Point: _spatialTypes.Point,\n  Date: _temporalTypes.Date,\n  DateTime: _temporalTypes.DateTime,\n  Duration: _temporalTypes.Duration,\n  LocalDateTime: _temporalTypes.LocalDateTime,\n  LocalTime: _temporalTypes.LocalTime,\n  Time: _temporalTypes.Time,\n  Integer: _integer[\"default\"]\n  /**\n   * Object containing string constants representing session access modes.\n   */\n\n};\nexports.types = types;\nvar session = {\n  READ: _driver.READ,\n  WRITE: _driver.WRITE\n  /**\n   * Object containing string constants representing predefined {@link Neo4jError} codes.\n   */\n\n};\nexports.session = session;\nvar error = {\n  SERVICE_UNAVAILABLE: _error.SERVICE_UNAVAILABLE,\n  SESSION_EXPIRED: _error.SESSION_EXPIRED,\n  PROTOCOL_ERROR: _error.PROTOCOL_ERROR\n  /**\n   * Object containing functions to work with {@link Integer} objects.\n   */\n\n};\nexports.error = error;\nvar integer = {\n  toNumber: _integer.toNumber,\n  toString: _integer.toString,\n  inSafeRange: _integer.inSafeRange\n  /**\n   * Object containing functions to work with spatial types, like {@link Point}.\n   */\n\n};\nexports.integer = integer;\nvar spatial = {\n  isPoint: _spatialTypes.isPoint\n  /**\n   * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.\n   */\n\n};\nexports.spatial = spatial;\nvar temporal = {\n  isDuration: _temporalTypes.isDuration,\n  isLocalTime: _temporalTypes.isLocalTime,\n  isTime: _temporalTypes.isTime,\n  isDate: _temporalTypes.isDate,\n  isLocalDateTime: _temporalTypes.isLocalDateTime,\n  isDateTime: _temporalTypes.isDateTime\n  /**\n   * @private\n   */\n\n};\nexports.temporal = temporal;\nvar forExport = {\n  driver: driver,\n  \"int\": _integer[\"int\"],\n  isInt: _integer.isInt,\n  isPoint: _spatialTypes.isPoint,\n  isDuration: _temporalTypes.isDuration,\n  isLocalTime: _temporalTypes.isLocalTime,\n  isTime: _temporalTypes.isTime,\n  isDate: _temporalTypes.isDate,\n  isLocalDateTime: _temporalTypes.isLocalDateTime,\n  isDateTime: _temporalTypes.isDateTime,\n  integer: integer,\n  Neo4jError: _error.Neo4jError,\n  auth: auth,\n  logging: logging,\n  types: types,\n  session: session,\n  error: error,\n  spatial: spatial,\n  temporal: temporal\n};\nvar _default = forExport;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}