{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n\nvar _integer = _interopRequireWildcard(require(\"../integer\"));\n\nvar _serverVersion = require(\"./server-version\");\n\nvar _bookmark = _interopRequireDefault(require(\"./bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./tx-config\"));\n\nvar _constants = require(\"./constants\");\n\nvar _serverAddress = _interopRequireDefault(require(\"./server-address\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar CALL_GET_SERVERS = 'CALL dbms.cluster.routing.getServers';\nvar CALL_GET_ROUTING_TABLE = 'CALL dbms.cluster.routing.getRoutingTable($context)';\nvar PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';\n\nvar RoutingUtil =\n/*#__PURE__*/\nfunction () {\n  function RoutingUtil(routingContext) {\n    (0, _classCallCheck2[\"default\"])(this, RoutingUtil);\n    this._routingContext = routingContext;\n  }\n  /**\n   * Invoke routing procedure using the given session.\n   * @param {Session} session the session to use.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if\n   * connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(RoutingUtil, [{\n    key: \"callRoutingProcedure\",\n    value: function callRoutingProcedure(session, routerAddress) {\n      return this._callAvailableRoutingProcedure(session).then(function (result) {\n        session.close();\n        return result.records;\n      })[\"catch\"](function (error) {\n        if (error.code === PROCEDURE_NOT_FOUND_CODE) {\n          // throw when getServers procedure not found because this is clearly a configuration issue\n          throw (0, _error.newError)(\"Server at \".concat(routerAddress.asHostPort(), \" can't perform routing. Make sure you are connecting to a causal cluster\"), _error.SERVICE_UNAVAILABLE);\n        } else {\n          // return nothing when failed to connect because code higher in the callstack is still able to retry with a\n          // different session towards a different router\n          return null;\n        }\n      });\n    }\n  }, {\n    key: \"parseTtl\",\n    value: function parseTtl(record, routerAddress) {\n      try {\n        var now = (0, _integer[\"int\"])(Date.now());\n        var expires = (0, _integer[\"int\"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n\n        if (expires.lessThan(now)) {\n          return _integer[\"default\"].MAX_VALUE;\n        }\n\n        return expires;\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse TTL entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"parseServers\",\n    value: function parseServers(record, routerAddress) {\n      try {\n        var servers = record.get('servers');\n        var routers = [];\n        var readers = [];\n        var writers = [];\n        servers.forEach(function (server) {\n          var role = server['role'];\n          var addresses = server['addresses'];\n\n          if (role === 'ROUTE') {\n            routers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'WRITE') {\n            writers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else if (role === 'READ') {\n            readers = parseArray(addresses).map(function (address) {\n              return _serverAddress[\"default\"].fromUrl(address);\n            });\n          } else {\n            throw (0, _error.newError)('Unknown server role \"' + role + '\"', _error.PROTOCOL_ERROR);\n          }\n        });\n        return {\n          routers: routers,\n          readers: readers,\n          writers: writers\n        };\n      } catch (error) {\n        throw (0, _error.newError)(\"Unable to parse servers entry from router \".concat(routerAddress, \" from record:\\n\").concat(JSON.stringify(record), \"\\nError message: \").concat(error.message), _error.PROTOCOL_ERROR);\n      }\n    }\n  }, {\n    key: \"_callAvailableRoutingProcedure\",\n    value: function _callAvailableRoutingProcedure(session) {\n      var _this = this;\n\n      return session._run(null, null, function (connection, streamObserver) {\n        var serverVersionString = connection.server.version;\n\n        var serverVersion = _serverVersion.ServerVersion.fromString(serverVersionString);\n\n        var query;\n        var params;\n\n        if (serverVersion.compareTo(_serverVersion.VERSION_3_2_0) >= 0) {\n          query = CALL_GET_ROUTING_TABLE;\n          params = {\n            context: _this._routingContext\n          };\n        } else {\n          query = CALL_GET_SERVERS;\n          params = {};\n        }\n\n        connection.protocol().run(query, params, _bookmark[\"default\"].empty(), _txConfig[\"default\"].empty(), _constants.ACCESS_MODE_WRITE, streamObserver);\n      });\n    }\n  }]);\n  return RoutingUtil;\n}();\n\nexports[\"default\"] = RoutingUtil;\n\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n\n  return Array.from(addresses);\n}","map":null,"metadata":{},"sourceType":"script"}