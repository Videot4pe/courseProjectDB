{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\n\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\n\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\n\nvar TransactionExecutor =\n/*#__PURE__*/\nfunction () {\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n    (0, _classCallCheck2[\"default\"])(this, TransactionExecutor);\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._inFlightTimeoutIds = [];\n\n    this._verifyAfterConstruction();\n  }\n\n  (0, _createClass2[\"default\"])(TransactionExecutor, [{\n    key: \"execute\",\n    value: function execute(transactionCreator, transactionWork) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n      })[\"catch\"](function (error) {\n        var retryStartTimeMs = Date.now();\n        var retryDelayMs = _this._initialRetryDelayMs;\n        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // cancel all existing timeouts to prevent further retries\n      this._inFlightTimeoutIds.forEach(function (timeoutId) {\n        return clearTimeout(timeoutId);\n      });\n\n      this._inFlightTimeoutIds = [];\n    }\n  }, {\n    key: \"_retryTransactionPromise\",\n    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n      var _this2 = this;\n\n      var elapsedTimeMs = Date.now() - retryStartTime;\n\n      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {\n        return Promise.reject(error);\n      }\n\n      return new Promise(function (resolve, reject) {\n        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);\n\n        var timeoutId = setTimeout(function () {\n          // filter out this timeoutId when time has come and function is being executed\n          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {\n            return id !== timeoutId;\n          });\n\n          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts\n\n        _this2._inFlightTimeoutIds.push(timeoutId);\n      })[\"catch\"](function (error) {\n        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;\n        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n      });\n    }\n  }, {\n    key: \"_executeTransactionInsidePromise\",\n    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {\n      var _this3 = this;\n\n      var tx;\n\n      try {\n        tx = transactionCreator();\n      } catch (error) {\n        // failed to create a transaction\n        reject(error);\n        return;\n      }\n\n      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n\n      resultPromise.then(function (result) {\n        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);\n      })[\"catch\"](function (error) {\n        return _this3._handleTransactionWorkFailure(error, tx, reject);\n      });\n    }\n  }, {\n    key: \"_safeExecuteTransactionWork\",\n    value: function _safeExecuteTransactionWork(tx, transactionWork) {\n      try {\n        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an\n        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n        // validation step without type checks\n\n        return Promise.resolve(result);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n  }, {\n    key: \"_handleTransactionWorkSuccess\",\n    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {\n      if (tx.isOpen()) {\n        // transaction work returned resolved promise and transaction has not been committed/rolled back\n        // try to commit the transaction\n        tx.commit().then(function () {\n          // transaction was committed, return result to the user\n          resolve(result);\n        })[\"catch\"](function (error) {\n          // transaction failed to commit, propagate the failure\n          reject(error);\n        });\n      } else {\n        // transaction work returned resolved promise and transaction is already committed/rolled back\n        // return the result returned by given transaction work\n        resolve(result);\n      }\n    }\n  }, {\n    key: \"_handleTransactionWorkFailure\",\n    value: function _handleTransactionWorkFailure(error, tx, reject) {\n      if (tx.isOpen()) {\n        // transaction work failed and the transaction is still open, roll it back and propagate the failure\n        tx.rollback()[\"catch\"](function (ignore) {// ignore the rollback error\n        }).then(function () {\n          return reject(error);\n        }); // propagate the original error we got from the transaction work\n      } else {\n        // transaction is already rolled back, propagate the error\n        reject(error);\n      }\n    }\n  }, {\n    key: \"_computeDelayWithJitter\",\n    value: function _computeDelayWithJitter(delayMs) {\n      var jitter = delayMs * this._jitterFactor;\n      var min = delayMs - jitter;\n      var max = delayMs + jitter;\n      return Math.random() * (max - min) + min;\n    }\n  }, {\n    key: \"_verifyAfterConstruction\",\n    value: function _verifyAfterConstruction() {\n      if (this._maxRetryTimeMs < 0) {\n        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n      }\n\n      if (this._initialRetryDelayMs < 0) {\n        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n      }\n\n      if (this._multiplier < 1.0) {\n        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n      }\n\n      if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n      }\n    }\n  }], [{\n    key: \"_canRetryOn\",\n    value: function _canRetryOn(error) {\n      return error && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));\n    }\n  }, {\n    key: \"_isTransientError\",\n    value: function _isTransientError(error) {\n      // Retries should not happen when transaction was explicitly terminated by the user.\n      // Termination of transaction might result in two different error codes depending on where it was\n      // terminated. These are really client errors but classification on the server is not entirely correct and\n      // they are classified as transient.\n      var code = error.code;\n\n      if (code.indexOf('TransientError') >= 0) {\n        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n  return TransactionExecutor;\n}();\n\nexports[\"default\"] = TransactionExecutor;\n\nfunction _valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n\n  return defaultValue;\n}","map":null,"metadata":{},"sourceType":"script"}