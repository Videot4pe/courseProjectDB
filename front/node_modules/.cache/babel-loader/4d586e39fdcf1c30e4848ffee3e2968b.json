{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _driver = require(\"./driver\");\n\nvar _error = require(\"./error\");\n\nvar _connectionProviders = require(\"./internal/connection-providers\");\n\nvar _leastConnectedLoadBalancingStrategy = _interopRequireWildcard(require(\"./internal/least-connected-load-balancing-strategy\"));\n\nvar _roundRobinLoadBalancingStrategy = _interopRequireWildcard(require(\"./internal/round-robin-load-balancing-strategy\"));\n\nvar _connectionErrorHandler = _interopRequireDefault(require(\"./internal/connection-error-handler\"));\n\nvar _configuredCustomResolver = _interopRequireDefault(require(\"./internal/resolver/configured-custom-resolver\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A driver that supports routing in a causal cluster.\n * @private\n */\n\n\nvar RoutingDriver =\n/*#__PURE__*/\nfunction (_Driver) {\n  (0, _inherits2[\"default\"])(RoutingDriver, _Driver);\n\n  function RoutingDriver(address, routingContext, userAgent) {\n    var _this;\n\n    var token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    (0, _classCallCheck2[\"default\"])(this, RoutingDriver);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(RoutingDriver).call(this, address, userAgent, token, validateConfig(config)));\n    _this._routingContext = routingContext;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(RoutingDriver, [{\n    key: \"_afterConstruction\",\n    value: function _afterConstruction() {\n      this._log.info(\"Routing driver \".concat(this._id, \" created for server address \").concat(this._address));\n    }\n  }, {\n    key: \"_createConnectionProvider\",\n    value: function _createConnectionProvider(address, connectionPool, driverOnErrorCallback) {\n      var loadBalancingStrategy = RoutingDriver._createLoadBalancingStrategy(this._config, connectionPool);\n\n      var resolver = createHostNameResolver(this._config);\n      return new _connectionProviders.LoadBalancer(address, this._routingContext, connectionPool, loadBalancingStrategy, resolver, driverOnErrorCallback, this._log);\n    }\n  }, {\n    key: \"_createConnectionErrorHandler\",\n    value: function _createConnectionErrorHandler() {\n      var _this2 = this; // connection errors mean SERVICE_UNAVAILABLE for direct driver but for routing driver they should only\n      // result in SESSION_EXPIRED because there might still exist other servers capable of serving the request\n\n\n      return new _connectionErrorHandler[\"default\"](_error.SESSION_EXPIRED, function (error, address) {\n        return _this2._handleUnavailability(error, address);\n      }, function (error, address) {\n        return _this2._handleWriteFailure(error, address);\n      });\n    }\n  }, {\n    key: \"_handleUnavailability\",\n    value: function _handleUnavailability(error, address) {\n      this._log.warn(\"Routing driver \".concat(this._id, \" will forget \").concat(address, \" because of an error \").concat(error.code, \" '\").concat(error.message, \"'\"));\n\n      this._connectionProvider.forget(address);\n\n      return error;\n    }\n  }, {\n    key: \"_handleWriteFailure\",\n    value: function _handleWriteFailure(error, address) {\n      this._log.warn(\"Routing driver \".concat(this._id, \" will forget writer \").concat(address, \" because of an error \").concat(error.code, \" '\").concat(error.message, \"'\"));\n\n      this._connectionProvider.forgetWriter(address);\n\n      return (0, _error.newError)('No longer possible to write to server at ' + address, _error.SESSION_EXPIRED);\n    }\n    /**\n     * Create new load balancing strategy based on the config.\n     * @param {object} config the user provided config.\n     * @param {Pool} connectionPool the connection pool for this driver.\n     * @return {LoadBalancingStrategy} new strategy.\n     * @private\n     */\n\n  }], [{\n    key: \"_createLoadBalancingStrategy\",\n    value: function _createLoadBalancingStrategy(config, connectionPool) {\n      var configuredValue = config.loadBalancingStrategy;\n\n      if (!configuredValue || configuredValue === _leastConnectedLoadBalancingStrategy.LEAST_CONNECTED_STRATEGY_NAME) {\n        return new _leastConnectedLoadBalancingStrategy[\"default\"](connectionPool);\n      } else if (configuredValue === _roundRobinLoadBalancingStrategy.ROUND_ROBIN_STRATEGY_NAME) {\n        return new _roundRobinLoadBalancingStrategy[\"default\"]();\n      } else {\n        throw (0, _error.newError)('Unknown load balancing strategy: ' + configuredValue);\n      }\n    }\n  }]);\n  return RoutingDriver;\n}(_driver.Driver);\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\n\n\nfunction createHostNameResolver(config) {\n  return new _configuredCustomResolver[\"default\"](config.resolver);\n}\n/**\n * @private\n * @returns {object} the given config.\n */\n\n\nfunction validateConfig(config) {\n  if (config.trust === 'TRUST_ON_FIRST_USE') {\n    throw (0, _error.newError)('The chosen trust mode is not compatible with a routing driver');\n  }\n\n  var resolver = config.resolver;\n\n  if (resolver && typeof resolver !== 'function') {\n    throw new TypeError(\"Configured resolver should be a function. Got: \".concat(resolver));\n  }\n\n  return config;\n}\n\nvar _default = RoutingDriver;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}