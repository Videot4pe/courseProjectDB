{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _baseBuf = _interopRequireDefault(require(\"./base-buf\"));\n\nvar _node = require(\"../node\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Buffer that combines multiple buffers, exposing them as one single buffer.\n */\n\n\nvar CombinedBuffer =\n/*#__PURE__*/\nfunction (_BaseBuffer) {\n  (0, _inherits2[\"default\"])(CombinedBuffer, _BaseBuffer);\n\n  function CombinedBuffer(buffers) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, CombinedBuffer);\n    var length = 0;\n\n    for (var i = 0; i < buffers.length; i++) {\n      length += buffers[i].length;\n    }\n\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(CombinedBuffer).call(this, length));\n    _this._buffers = buffers;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(CombinedBuffer, [{\n    key: \"getUInt8\",\n    value: function getUInt8(position) {\n      // Surely there's a faster way to do this.. some sort of lookup table thing?\n      for (var i = 0; i < this._buffers.length; i++) {\n        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer\n\n        if (position >= buffer.length) {\n          position -= buffer.length;\n        } else {\n          return buffer.getUInt8(position);\n        }\n      }\n    }\n  }, {\n    key: \"getInt8\",\n    value: function getInt8(position) {\n      // Surely there's a faster way to do this.. some sort of lookup table thing?\n      for (var i = 0; i < this._buffers.length; i++) {\n        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer\n\n        if (position >= buffer.length) {\n          position -= buffer.length;\n        } else {\n          return buffer.getInt8(position);\n        }\n      }\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64(position) {\n      // At some point, a more efficient impl. For now, we copy the 8 bytes\n      // we want to read and depend on the platform impl of IEEE 754.\n      var b = (0, _node.alloc)(8);\n\n      for (var i = 0; i < 8; i++) {\n        b.putUInt8(i, this.getUInt8(position + i));\n      }\n\n      return b.getFloat64(0);\n    }\n  }]);\n  return CombinedBuffer;\n}(_baseBuf[\"default\"]);\n\nexports[\"default\"] = CombinedBuffer;","map":null,"metadata":{},"sourceType":"script"}