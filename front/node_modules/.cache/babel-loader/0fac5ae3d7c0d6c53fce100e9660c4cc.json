{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SingleConnectionProvider = exports.LoadBalancer = exports.DirectConnectionProvider = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n\nvar _driver = require(\"../driver\");\n\nvar _session = _interopRequireDefault(require(\"../session\"));\n\nvar _routingTable = _interopRequireDefault(require(\"./routing-table\"));\n\nvar _rediscovery = _interopRequireDefault(require(\"./rediscovery\"));\n\nvar _routingUtil = _interopRequireDefault(require(\"./routing-util\"));\n\nvar _node = require(\"./node\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar UNAUTHORIZED_ERROR_CODE = 'Neo.ClientError.Security.Unauthorized';\n\nvar ConnectionProvider =\n/*#__PURE__*/\nfunction () {\n  function ConnectionProvider() {\n    (0, _classCallCheck2[\"default\"])(this, ConnectionProvider);\n  }\n\n  (0, _createClass2[\"default\"])(ConnectionProvider, [{\n    key: \"acquireConnection\",\n    value: function acquireConnection(mode) {\n      throw new Error('Abstract function');\n    }\n  }, {\n    key: \"_withAdditionalOnErrorCallback\",\n    value: function _withAdditionalOnErrorCallback(connectionPromise, driverOnErrorCallback) {\n      // install error handler from the driver on the connection promise; this callback is installed separately\n      // so that it does not handle errors, instead it is just an additional error reporting facility.\n      connectionPromise[\"catch\"](function (error) {\n        driverOnErrorCallback(error);\n      }); // return the original connection promise\n\n      return connectionPromise;\n    }\n  }]);\n  return ConnectionProvider;\n}();\n\nvar DirectConnectionProvider =\n/*#__PURE__*/\nfunction (_ConnectionProvider) {\n  (0, _inherits2[\"default\"])(DirectConnectionProvider, _ConnectionProvider);\n\n  function DirectConnectionProvider(address, connectionPool, driverOnErrorCallback) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, DirectConnectionProvider);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(DirectConnectionProvider).call(this));\n    _this._address = address;\n    _this._connectionPool = connectionPool;\n    _this._driverOnErrorCallback = driverOnErrorCallback;\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(DirectConnectionProvider, [{\n    key: \"acquireConnection\",\n    value: function acquireConnection(mode) {\n      var connectionPromise = this._connectionPool.acquire(this._address);\n\n      return this._withAdditionalOnErrorCallback(connectionPromise, this._driverOnErrorCallback);\n    }\n  }]);\n  return DirectConnectionProvider;\n}(ConnectionProvider);\n\nexports.DirectConnectionProvider = DirectConnectionProvider;\n\nvar LoadBalancer =\n/*#__PURE__*/\nfunction (_ConnectionProvider2) {\n  (0, _inherits2[\"default\"])(LoadBalancer, _ConnectionProvider2);\n\n  function LoadBalancer(address, routingContext, connectionPool, loadBalancingStrategy, hostNameResolver, driverOnErrorCallback, log) {\n    var _this2;\n\n    (0, _classCallCheck2[\"default\"])(this, LoadBalancer);\n    _this2 = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(LoadBalancer).call(this));\n    _this2._seedRouter = address;\n    _this2._routingTable = new _routingTable[\"default\"]();\n    _this2._rediscovery = new _rediscovery[\"default\"](new _routingUtil[\"default\"](routingContext));\n    _this2._connectionPool = connectionPool;\n    _this2._driverOnErrorCallback = driverOnErrorCallback;\n    _this2._loadBalancingStrategy = loadBalancingStrategy;\n    _this2._hostNameResolver = hostNameResolver;\n    _this2._dnsResolver = new _node.HostNameResolver();\n    _this2._log = log;\n    _this2._useSeedRouter = true;\n    return _this2;\n  }\n\n  (0, _createClass2[\"default\"])(LoadBalancer, [{\n    key: \"acquireConnection\",\n    value: function acquireConnection(accessMode) {\n      var _this3 = this;\n\n      var connectionPromise = this._freshRoutingTable(accessMode).then(function (routingTable) {\n        if (accessMode === _driver.READ) {\n          var address = _this3._loadBalancingStrategy.selectReader(routingTable.readers);\n\n          return _this3._acquireConnectionToServer(address, 'read');\n        } else if (accessMode === _driver.WRITE) {\n          var _address = _this3._loadBalancingStrategy.selectWriter(routingTable.writers);\n\n          return _this3._acquireConnectionToServer(_address, 'write');\n        } else {\n          throw (0, _error.newError)('Illegal mode ' + accessMode);\n        }\n      });\n\n      return this._withAdditionalOnErrorCallback(connectionPromise, this._driverOnErrorCallback);\n    }\n  }, {\n    key: \"forget\",\n    value: function forget(address) {\n      this._routingTable.forget(address);\n\n      this._connectionPool.purge(address);\n    }\n  }, {\n    key: \"forgetWriter\",\n    value: function forgetWriter(address) {\n      this._routingTable.forgetWriter(address);\n    }\n  }, {\n    key: \"_acquireConnectionToServer\",\n    value: function _acquireConnectionToServer(address, serverName) {\n      if (!address) {\n        return Promise.reject((0, _error.newError)(\"Failed to obtain connection towards \".concat(serverName, \" server. Known routing table is: \").concat(this._routingTable), _error.SESSION_EXPIRED));\n      }\n\n      return this._connectionPool.acquire(address);\n    }\n  }, {\n    key: \"_freshRoutingTable\",\n    value: function _freshRoutingTable(accessMode) {\n      var currentRoutingTable = this._routingTable;\n\n      if (!currentRoutingTable.isStaleFor(accessMode)) {\n        return Promise.resolve(currentRoutingTable);\n      }\n\n      this._log.info(\"Routing table is stale for \".concat(accessMode, \": \").concat(currentRoutingTable));\n\n      return this._refreshRoutingTable(currentRoutingTable);\n    }\n  }, {\n    key: \"_refreshRoutingTable\",\n    value: function _refreshRoutingTable(currentRoutingTable) {\n      var knownRouters = currentRoutingTable.routers;\n\n      if (this._useSeedRouter) {\n        return this._fetchRoutingTableFromSeedRouterFallbackToKnownRouters(knownRouters, currentRoutingTable);\n      }\n\n      return this._fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(knownRouters, currentRoutingTable);\n    }\n  }, {\n    key: \"_fetchRoutingTableFromSeedRouterFallbackToKnownRouters\",\n    value: function _fetchRoutingTableFromSeedRouterFallbackToKnownRouters(knownRouters, currentRoutingTable) {\n      var _this4 = this; // we start with seed router, no routers were probed before\n\n\n      var seenRouters = [];\n      return this._fetchRoutingTableUsingSeedRouter(seenRouters, this._seedRouter).then(function (newRoutingTable) {\n        if (newRoutingTable) {\n          _this4._useSeedRouter = false;\n          return newRoutingTable;\n        } // seed router did not return a valid routing table - try to use other known routers\n\n\n        return _this4._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable);\n      }).then(function (newRoutingTable) {\n        _this4._applyRoutingTableIfPossible(newRoutingTable);\n\n        return newRoutingTable;\n      });\n    }\n  }, {\n    key: \"_fetchRoutingTableFromKnownRoutersFallbackToSeedRouter\",\n    value: function _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(knownRouters, currentRoutingTable) {\n      var _this5 = this;\n\n      return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable).then(function (newRoutingTable) {\n        if (newRoutingTable) {\n          return newRoutingTable;\n        } // none of the known routers returned a valid routing table - try to use seed router address for rediscovery\n\n\n        return _this5._fetchRoutingTableUsingSeedRouter(knownRouters, _this5._seedRouter);\n      }).then(function (newRoutingTable) {\n        _this5._applyRoutingTableIfPossible(newRoutingTable);\n\n        return newRoutingTable;\n      });\n    }\n  }, {\n    key: \"_fetchRoutingTableUsingKnownRouters\",\n    value: function _fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable) {\n      return this._fetchRoutingTable(knownRouters, currentRoutingTable).then(function (newRoutingTable) {\n        if (newRoutingTable) {\n          // one of the known routers returned a valid routing table - use it\n          return newRoutingTable;\n        } // returned routing table was undefined, this means a connection error happened and the last known\n        // router did not return a valid routing table, so we need to forget it\n\n\n        var lastRouterIndex = knownRouters.length - 1;\n\n        LoadBalancer._forgetRouter(currentRoutingTable, knownRouters, lastRouterIndex);\n\n        return null;\n      });\n    }\n  }, {\n    key: \"_fetchRoutingTableUsingSeedRouter\",\n    value: function _fetchRoutingTableUsingSeedRouter(seenRouters, seedRouter) {\n      var _this6 = this;\n\n      var resolvedAddresses = this._resolveSeedRouter(seedRouter);\n\n      return resolvedAddresses.then(function (resolvedRouterAddresses) {\n        // filter out all addresses that we've already tried\n        var newAddresses = resolvedRouterAddresses.filter(function (address) {\n          return seenRouters.indexOf(address) < 0;\n        });\n        return _this6._fetchRoutingTable(newAddresses, null);\n      });\n    }\n  }, {\n    key: \"_resolveSeedRouter\",\n    value: function _resolveSeedRouter(seedRouter) {\n      var _this7 = this;\n\n      var customResolution = this._hostNameResolver.resolve(seedRouter);\n\n      var dnsResolutions = customResolution.then(function (resolvedAddresses) {\n        return Promise.all(resolvedAddresses.map(function (address) {\n          return _this7._dnsResolver.resolve(address);\n        }));\n      });\n      return dnsResolutions.then(function (results) {\n        return [].concat.apply([], results);\n      });\n    }\n  }, {\n    key: \"_fetchRoutingTable\",\n    value: function _fetchRoutingTable(routerAddresses, routingTable) {\n      var _this8 = this;\n\n      return routerAddresses.reduce(function (refreshedTablePromise, currentRouter, currentIndex) {\n        return refreshedTablePromise.then(function (newRoutingTable) {\n          if (newRoutingTable) {\n            // valid routing table was fetched - just return it, try next router otherwise\n            return newRoutingTable;\n          } else {\n            // returned routing table was undefined, this means a connection error happened and we need to forget the\n            // previous router and try the next one\n            var previousRouterIndex = currentIndex - 1;\n\n            LoadBalancer._forgetRouter(routingTable, routerAddresses, previousRouterIndex);\n          } // try next router\n\n\n          return _this8._createSessionForRediscovery(currentRouter).then(function (session) {\n            if (session) {\n              return _this8._rediscovery.lookupRoutingTableOnRouter(session, currentRouter)[\"catch\"](function (error) {\n                _this8._log.warn(\"unable to fetch routing table because of an error \".concat(error));\n\n                return null;\n              });\n            } else {\n              // unable to acquire connection and create session towards the current router\n              // return null to signal that the next router should be tried\n              return null;\n            }\n          });\n        });\n      }, Promise.resolve(null));\n    }\n  }, {\n    key: \"_createSessionForRediscovery\",\n    value: function _createSessionForRediscovery(routerAddress) {\n      return this._connectionPool.acquire(routerAddress).then(function (connection) {\n        var connectionProvider = new SingleConnectionProvider(connection);\n        return new _session[\"default\"](_driver.READ, connectionProvider);\n      })[\"catch\"](function (error) {\n        // unable to acquire connection towards the given router\n        if (error && error.code === UNAUTHORIZED_ERROR_CODE) {\n          // auth error is a sign of a configuration issue, rediscovery should not proceed\n          throw error;\n        }\n\n        return null;\n      });\n    }\n  }, {\n    key: \"_applyRoutingTableIfPossible\",\n    value: function _applyRoutingTableIfPossible(newRoutingTable) {\n      if (!newRoutingTable) {\n        // none of routing servers returned valid routing table, throw exception\n        throw (0, _error.newError)(\"Could not perform discovery. No routing servers available. Known routing table: \".concat(this._routingTable), _error.SERVICE_UNAVAILABLE);\n      }\n\n      if (newRoutingTable.writers.length === 0) {\n        // use seed router next time. this is important when cluster is partitioned. it tries to make sure driver\n        // does not always get routing table without writers because it talks exclusively to a minority partition\n        this._useSeedRouter = true;\n      }\n\n      this._updateRoutingTable(newRoutingTable);\n    }\n  }, {\n    key: \"_updateRoutingTable\",\n    value: function _updateRoutingTable(newRoutingTable) {\n      // close old connections to servers not present in the new routing table\n      this._connectionPool.keepAll(newRoutingTable.allServers()); // make this driver instance aware of the new table\n\n\n      this._routingTable = newRoutingTable;\n\n      this._log.info(\"Updated routing table \".concat(newRoutingTable));\n    }\n  }], [{\n    key: \"_forgetRouter\",\n    value: function _forgetRouter(routingTable, routersArray, routerIndex) {\n      var address = routersArray[routerIndex];\n\n      if (routingTable && address) {\n        routingTable.forgetRouter(address);\n      }\n    }\n  }]);\n  return LoadBalancer;\n}(ConnectionProvider);\n\nexports.LoadBalancer = LoadBalancer;\n\nvar SingleConnectionProvider =\n/*#__PURE__*/\nfunction (_ConnectionProvider3) {\n  (0, _inherits2[\"default\"])(SingleConnectionProvider, _ConnectionProvider3);\n\n  function SingleConnectionProvider(connection) {\n    var _this9;\n\n    (0, _classCallCheck2[\"default\"])(this, SingleConnectionProvider);\n    _this9 = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(SingleConnectionProvider).call(this));\n    _this9._connection = connection;\n    return _this9;\n  }\n\n  (0, _createClass2[\"default\"])(SingleConnectionProvider, [{\n    key: \"acquireConnection\",\n    value: function acquireConnection(mode) {\n      var connection = this._connection;\n      this._connection = null;\n      return Promise.resolve(connection);\n    }\n  }]);\n  return SingleConnectionProvider;\n}(ConnectionProvider);\n\nexports.SingleConnectionProvider = SingleConnectionProvider;","map":null,"metadata":{},"sourceType":"script"}