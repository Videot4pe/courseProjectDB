{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _baseBuf = _interopRequireDefault(require(\"../buf/base-buf\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar HeapBuffer =\n/*#__PURE__*/\nfunction (_BaseBuffer) {\n  (0, _inherits2[\"default\"])(HeapBuffer, _BaseBuffer);\n\n  function HeapBuffer(arg) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, HeapBuffer);\n    var buffer = arg instanceof ArrayBuffer ? arg : new ArrayBuffer(arg);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(HeapBuffer).call(this, buffer.byteLength));\n    _this._buffer = buffer;\n    _this._view = new DataView(_this._buffer);\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(HeapBuffer, [{\n    key: \"putUInt8\",\n    value: function putUInt8(position, val) {\n      this._view.setUint8(position, val);\n    }\n  }, {\n    key: \"getUInt8\",\n    value: function getUInt8(position) {\n      return this._view.getUint8(position);\n    }\n  }, {\n    key: \"putInt8\",\n    value: function putInt8(position, val) {\n      this._view.setInt8(position, val);\n    }\n  }, {\n    key: \"getInt8\",\n    value: function getInt8(position) {\n      return this._view.getInt8(position);\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64(position) {\n      return this._view.getFloat64(position);\n    }\n  }, {\n    key: \"putFloat64\",\n    value: function putFloat64(position, val) {\n      this._view.setFloat64(position, val);\n    }\n  }, {\n    key: \"getSlice\",\n    value: function getSlice(start, length) {\n      if (this._buffer.slice) {\n        return new HeapBuffer(this._buffer.slice(start, start + length));\n      } else {\n        // Some platforms (eg. phantomjs) don't support slice, so fall back to a copy\n        // We do this rather than return a SliceBuffer, because sliceBuffer cannot\n        // be passed to native network write ops etc - we need ArrayBuffer for that\n        var copy = new HeapBuffer(length);\n\n        for (var i = 0; i < length; i++) {\n          copy.putUInt8(i, this.getUInt8(i + start));\n        }\n\n        return copy;\n      }\n    }\n    /**\n     * Specific to HeapBuffer, this gets a DataView from the\n     * current position and of the specified length.\n     */\n\n  }, {\n    key: \"readView\",\n    value: function readView(length) {\n      return new DataView(this._buffer, this._updatePos(length), length);\n    }\n  }]);\n  return HeapBuffer;\n}(_baseBuf[\"default\"]);\n\nexports[\"default\"] = HeapBuffer;","map":null,"metadata":{},"sourceType":"script"}