{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.WRITE = exports.READ = exports.Driver = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _session = _interopRequireDefault(require(\"./session\"));\n\nvar _pool = _interopRequireDefault(require(\"./internal/pool\"));\n\nvar _connection = _interopRequireDefault(require(\"./internal/connection\"));\n\nvar _error = require(\"./error\");\n\nvar _connectionProviders = require(\"./internal/connection-providers\");\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _connectivityVerifier = _interopRequireDefault(require(\"./internal/connectivity-verifier\"));\n\nvar _poolConfig = _interopRequireWildcard(require(\"./internal/pool-config\"));\n\nvar _logger = _interopRequireDefault(require(\"./internal/logger\"));\n\nvar _connectionErrorHandler = _interopRequireDefault(require(\"./internal/connection-error-handler\"));\n\nvar _constants = require(\"./internal/constants\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session(neo4j.session.READ)`.\n * @type {string}\n */\n\nvar READ = _constants.ACCESS_MODE_READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session(neo4j.session.WRITE)`.\n * @type {string}\n */\n\nexports.READ = READ;\nvar WRITE = _constants.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send statements\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\n\nvar Driver =\n/*#__PURE__*/\nfunction () {\n  /**\n   * You should not be calling this directly, instead use {@link driver}.\n   * @constructor\n   * @param {ServerAddress} address\n   * @param {string} userAgent\n   * @param {object} authToken\n   * @param {object} config\n   * @protected\n   */\n  function Driver(address, userAgent) {\n    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    (0, _classCallCheck2[\"default\"])(this, Driver);\n    sanitizeConfig(config);\n    this._id = idGenerator++;\n    this._address = address;\n    this._userAgent = userAgent;\n    this._openConnections = {};\n    this._authToken = authToken;\n    this._config = config;\n    this._log = _logger[\"default\"].create(config);\n    this._pool = new _pool[\"default\"]({\n      create: this._createConnection.bind(this),\n      destroy: this._destroyConnection.bind(this),\n      validate: this._validateConnection.bind(this),\n      installIdleObserver: this._installIdleObserverOnConnection.bind(this),\n      removeIdleObserver: this._removeIdleObserverOnConnection.bind(this),\n      config: _poolConfig[\"default\"].fromDriverConfig(config),\n      log: this._log\n    });\n    /**\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n     * @type {ConnectionProvider}\n     * @protected\n     */\n\n    this._connectionProvider = null;\n    this._onCompleted = null;\n\n    this._afterConstruction();\n  }\n  /**\n   * @protected\n   */\n\n\n  (0, _createClass2[\"default\"])(Driver, [{\n    key: \"_afterConstruction\",\n    value: function _afterConstruction() {\n      this._log.info(\"Direct driver \".concat(this._id, \" created for server address \").concat(this._address));\n    }\n    /**\n     * Get the installed connectivity verification callback.\n     * @return {null|function}\n     * @deprecated driver can be used directly once instantiated, use of this callback is not required.\n     */\n\n  }, {\n    key: \"_createConnection\",\n\n    /**\n     * Create a new connection and initialize it.\n     * @return {Promise<Connection>} promise resolved with a new connection or rejected when failed to connect.\n     * @access private\n     */\n    value: function _createConnection(address, release) {\n      var _this = this;\n\n      var connection = _connection[\"default\"].create(address, this._config, this._createConnectionErrorHandler(), this._log);\n\n      connection._release = function () {\n        return release(address, connection);\n      };\n\n      this._openConnections[connection.id] = connection;\n      return connection.connect(this._userAgent, this._authToken)[\"catch\"](function (error) {\n        if (_this.onError) {\n          // notify Driver.onError callback about connection initialization errors\n          _this.onError(error);\n        } // let's destroy this connection\n\n\n        _this._destroyConnection(connection); // propagate the error because connection failed to connect / initialize\n\n\n        throw error;\n      });\n    }\n    /**\n     * Check that a connection is usable\n     * @return {boolean} true if the connection is open\n     * @access private\n     **/\n\n  }, {\n    key: \"_validateConnection\",\n    value: function _validateConnection(conn) {\n      if (!conn.isOpen()) {\n        return false;\n      }\n\n      var maxConnectionLifetime = this._config.maxConnectionLifetime;\n      var lifetime = Date.now() - conn.creationTimestamp;\n      return lifetime <= maxConnectionLifetime;\n    }\n  }, {\n    key: \"_installIdleObserverOnConnection\",\n    value: function _installIdleObserverOnConnection(conn, observer) {\n      conn._queueObserver(observer);\n    }\n  }, {\n    key: \"_removeIdleObserverOnConnection\",\n    value: function _removeIdleObserverOnConnection(conn) {\n      conn._updateCurrentObserver();\n    }\n    /**\n     * Dispose of a connection.\n     * @return {Connection} the connection to dispose.\n     * @access private\n     */\n\n  }, {\n    key: \"_destroyConnection\",\n    value: function _destroyConnection(conn) {\n      delete this._openConnections[conn.id];\n      conn.close();\n    }\n    /**\n     * Acquire a session to communicate with the database. The session will\n     * borrow connections from the underlying connection pool as required and\n     * should be considered lightweight and disposable.\n     *\n     * This comes with some responsibility - make sure you always call\n     * {@link close} when you are done using a session, and likewise,\n     * make sure you don't close your session before you are done using it. Once\n     * it is closed, the underlying connection will be released to the connection\n     * pool and made available for others to use.\n     *\n     * @param {string} [mode=WRITE] the access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n     * @param {string|string[]} [bookmarkOrBookmarks=null] the initial reference or references to some previous\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n     * @return {Session} new session.\n     */\n\n  }, {\n    key: \"session\",\n    value: function session(mode, bookmarkOrBookmarks) {\n      var sessionMode = Driver._validateSessionMode(mode);\n\n      var connectionProvider = this._getOrCreateConnectionProvider();\n\n      var bookmark = bookmarkOrBookmarks ? new _bookmark[\"default\"](bookmarkOrBookmarks) : _bookmark[\"default\"].empty();\n      return new _session[\"default\"](sessionMode, connectionProvider, bookmark, this._config);\n    }\n  }, {\n    key: \"_createConnectionProvider\",\n    // Extension point\n    value: function _createConnectionProvider(address, connectionPool, driverOnErrorCallback) {\n      return new _connectionProviders.DirectConnectionProvider(address, connectionPool, driverOnErrorCallback);\n    } // Extension point\n\n  }, {\n    key: \"_createConnectionErrorHandler\",\n    value: function _createConnectionErrorHandler() {\n      return new _connectionErrorHandler[\"default\"](_error.SERVICE_UNAVAILABLE);\n    }\n  }, {\n    key: \"_getOrCreateConnectionProvider\",\n    value: function _getOrCreateConnectionProvider() {\n      if (!this._connectionProvider) {\n        var driverOnErrorCallback = this._driverOnErrorCallback.bind(this);\n\n        this._connectionProvider = this._createConnectionProvider(this._address, this._pool, driverOnErrorCallback);\n      }\n\n      return this._connectionProvider;\n    }\n  }, {\n    key: \"_driverOnErrorCallback\",\n    value: function _driverOnErrorCallback(error) {\n      var userDefinedOnErrorCallback = this.onError;\n\n      if (userDefinedOnErrorCallback && error.code === _error.SERVICE_UNAVAILABLE) {\n        userDefinedOnErrorCallback(error);\n      } else {// we don't need to tell the driver about this error\n      }\n    }\n    /**\n     * Close all open sessions and other associated resources. You should\n     * make sure to use this when you are done with this driver instance.\n     * @return undefined\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._log.info(\"Driver \".concat(this._id, \" closing\"));\n\n      try {\n        // purge all idle connections in the connection pool\n        this._pool.purgeAll();\n      } finally {\n        // then close all connections driver has ever created\n        // it is needed to close connections that are active right now and are acquired from the pool\n        for (var connectionId in this._openConnections) {\n          if (this._openConnections.hasOwnProperty(connectionId)) {\n            this._openConnections[connectionId].close();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"onCompleted\",\n    get: function get() {\n      return this._onCompleted;\n    }\n    /**\n     * Install a connectivity verification callback.\n     * @param {null|function} callback the new function to be notified about successful connection.\n     * @deprecated driver can be used directly once instantiated, use of this callback is not required.\n     */\n    ,\n    set: function set(callback) {\n      this._onCompleted = callback;\n\n      if (this._onCompleted) {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n\n        var connectivityVerifier = new _connectivityVerifier[\"default\"](connectionProvider, this._onCompleted);\n        connectivityVerifier.verify();\n      }\n    }\n  }], [{\n    key: \"_validateSessionMode\",\n    value: function _validateSessionMode(rawMode) {\n      var mode = rawMode || WRITE;\n\n      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {\n        throw (0, _error.newError)('Illegal session mode ' + mode);\n      }\n\n      return mode;\n    }\n  }]);\n  return Driver;\n}();\n/**\n * @private\n */\n\n\nexports.Driver = Driver;\n\nfunction sanitizeConfig(config) {\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);\n}\n\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n  var sanitizedValue = parseInt(rawValue, 10);\n\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\n    return sanitizedValue;\n  } else if (sanitizedValue < 0) {\n    return Number.MAX_SAFE_INTEGER;\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n\nvar _default = Driver;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}