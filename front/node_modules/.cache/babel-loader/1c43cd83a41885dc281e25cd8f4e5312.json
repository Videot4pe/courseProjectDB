{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _node = require(\"./node\");\n\nvar _chunking = require(\"./chunking\");\n\nvar _error = require(\"./../error\");\n\nvar _channelConfig = _interopRequireDefault(require(\"./channel-config\"));\n\nvar _serverVersion = require(\"./server-version\");\n\nvar _protocolHandshaker = _interopRequireDefault(require(\"./protocol-handshaker\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Signature bytes for each response message type\n\n\nvar SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>\n\nvar RECORD = 0x71; // 0111 0001 // RECORD <value>\n\nvar IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>\n\nvar FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>\n\nfunction NO_OP() {}\n\nvar NO_OP_OBSERVER = {\n  onNext: NO_OP,\n  onCompleted: NO_OP,\n  onError: NO_OP\n};\nvar idGenerator = 0;\n\nvar Connection =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.\n   * @param {ConnectionErrorHandler} errorHandler the error handler.\n   * @param {ServerAddress} address - the server address to connect to.\n   * @param {Logger} log - the configured logger.\n   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.\n   */\n  function Connection(channel, errorHandler, address, log) {\n    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    (0, _classCallCheck2[\"default\"])(this, Connection);\n    this.id = idGenerator++;\n    this.address = address;\n    this.server = {\n      address: address.asHostPort()\n    };\n    this.creationTimestamp = Date.now();\n    this._errorHandler = errorHandler;\n    this._disableLosslessIntegers = disableLosslessIntegers;\n    this._pendingObservers = [];\n    this._currentObserver = undefined;\n    this._ch = channel;\n    this._dechunker = new _chunking.Dechunker();\n    this._chunker = new _chunking.Chunker(channel);\n    this._log = log; // connection from the database, returned in response for HELLO message and might not be available\n\n    this._dbConnectionId = null; // bolt protocol is initially not initialized\n\n    this._protocol = null; // error extracted from a FAILURE message\n\n    this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.\n\n    this._isBroken = false;\n\n    if (this._log.isDebugEnabled()) {\n      this._log.debug(\"\".concat(this, \" created towards \").concat(address));\n    }\n  }\n  /**\n   * Crete new connection to the provided address. Returned connection is not connected.\n   * @param {ServerAddress} address - the Bolt endpoint to connect to.\n   * @param {object} config - this driver configuration.\n   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.\n   * @param {Logger} log - configured logger.\n   * @return {Connection} - new connection.\n   */\n\n\n  (0, _createClass2[\"default\"])(Connection, [{\n    key: \"connect\",\n\n    /**\n     * Connect to the target address, negotiate Bolt protocol and send initialization message.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.\n     */\n    value: function connect(userAgent, authToken) {\n      var _this = this;\n\n      return this._negotiateProtocol().then(function () {\n        return _this._initialize(userAgent, authToken);\n      });\n    }\n    /**\n     * Execute Bolt protocol handshake to initialize the protocol version.\n     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_negotiateProtocol\",\n    value: function _negotiateProtocol() {\n      var _this2 = this;\n\n      var protocolHandshaker = new _protocolHandshaker[\"default\"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log);\n      return new Promise(function (resolve, reject) {\n        var handshakeErrorHandler = function handshakeErrorHandler(error) {\n          _this2._handleFatalError(error);\n\n          reject(error);\n        };\n\n        _this2._ch.onerror = handshakeErrorHandler.bind(_this2);\n\n        if (_this2._ch._error) {\n          // channel is already broken\n          handshakeErrorHandler(_this2._ch._error);\n        }\n\n        _this2._ch.onmessage = function (buffer) {\n          try {\n            // read the response buffer and initialize the protocol\n            _this2._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise\n\n            _this2._ch.onerror = _this2._handleFatalError.bind(_this2); // Ok, protocol running. Simply forward all messages to the dechunker\n\n            _this2._ch.onmessage = function (buf) {\n              return _this2._dechunker.write(buf);\n            }; // setup dechunker to dechunk messages and forward them to the message handler\n\n\n            _this2._dechunker.onmessage = function (buf) {\n              _this2._handleMessage(_this2._protocol.unpacker().unpack(buf));\n            }; // forward all pending bytes to the dechunker\n\n\n            if (buffer.hasRemaining()) {\n              _this2._dechunker.write(buffer.readSlice(buffer.remaining()));\n            }\n\n            resolve(_this2);\n          } catch (e) {\n            _this2._handleFatalError(e);\n\n            reject(e);\n          }\n        };\n\n        protocolHandshaker.writeHandshakeRequest();\n      });\n    }\n    /**\n     * Perform protocol-specific initialization which includes authentication.\n     * @param {string} userAgent the user agent for this driver.\n     * @param {object} authToken the object containing auth information.\n     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(userAgent, authToken) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var observer = new InitializationObserver(_this3, resolve, reject);\n\n        _this3._protocol.initialize(userAgent, authToken, observer);\n      });\n    }\n    /**\n     * Get the Bolt protocol for the connection.\n     * @return {BoltProtocol} the protocol.\n     */\n\n  }, {\n    key: \"protocol\",\n    value: function protocol() {\n      return this._protocol;\n    }\n    /**\n     * Write a message to the network channel.\n     * @param {RequestMessage} message the message to write.\n     * @param {StreamObserver} observer the response observer.\n     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(message, observer, flush) {\n      var _this4 = this;\n\n      var queued = this._queueObserver(observer);\n\n      if (queued) {\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"\".concat(this, \" C: \").concat(message));\n        }\n\n        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {\n          return _this4._packable(field);\n        }), function (err) {\n          return _this4._handleFatalError(err);\n        });\n\n        this._chunker.messageBoundary();\n\n        if (flush) {\n          this._chunker.flush();\n        }\n      }\n    }\n    /**\n     * \"Fatal\" means the connection is dead. Only call this if something\n     * happens that cannot be recovered from. This will lead to all subscribers\n     * failing, and the connection getting ejected from the session pool.\n     *\n     * @param error an error object, forwarded to all current and future subscribers\n     */\n\n  }, {\n    key: \"_handleFatalError\",\n    value: function _handleFatalError(error) {\n      this._isBroken = true;\n      this._error = this._errorHandler.handleAndTransformError(error, this.address);\n\n      if (this._log.isErrorEnabled()) {\n        this._log.error(\"\".concat(this, \" experienced a fatal error \").concat(JSON.stringify(this._error)));\n      }\n\n      if (this._currentObserver && this._currentObserver.onError) {\n        this._currentObserver.onError(this._error);\n      }\n\n      while (this._pendingObservers.length > 0) {\n        var observer = this._pendingObservers.shift();\n\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n      }\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(msg) {\n      if (this._isBroken) {\n        // ignore all incoming messages when this connection is broken. all previously pending observers failed\n        // with the fatal error. all future observers will fail with same fatal error.\n        return;\n      }\n\n      var payload = msg.fields[0];\n\n      switch (msg.signature) {\n        case RECORD:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: RECORD \").concat(JSON.stringify(msg)));\n          }\n\n          this._currentObserver.onNext(payload);\n\n          break;\n\n        case SUCCESS:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: SUCCESS \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var metadata = this._protocol.transformMetadata(payload);\n\n            this._currentObserver.onCompleted(metadata);\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        case FAILURE:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: FAILURE \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            var error = (0, _error.newError)(payload.message, payload.code);\n            this._currentFailure = this._errorHandler.handleAndTransformError(error, this.address);\n\n            this._currentObserver.onError(this._currentFailure);\n          } finally {\n            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.\n\n\n            this._resetOnFailure();\n          }\n\n          break;\n\n        case IGNORED:\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(this, \" S: IGNORED \").concat(JSON.stringify(msg)));\n          }\n\n          try {\n            if (this._currentFailure && this._currentObserver.onError) {\n              this._currentObserver.onError(this._currentFailure);\n            } else if (this._currentObserver.onError) {\n              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));\n            }\n          } finally {\n            this._updateCurrentObserver();\n          }\n\n          break;\n\n        default:\n          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));\n\n      }\n    }\n    /**\n     * Send a RESET-message to the database. Message is immediately flushed to the network.\n     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.\n     */\n\n  }, {\n    key: \"resetAndFlush\",\n    value: function resetAndFlush() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5._protocol.reset({\n          onNext: function onNext(record) {\n            var neo4jError = _this5._handleProtocolError('Received RECORD as a response for RESET: ' + JSON.stringify(record));\n\n            reject(neo4jError);\n          },\n          onError: function onError(error) {\n            if (_this5._isBroken) {\n              // handling a fatal error, no need to raise a protocol violation\n              reject(error);\n            } else {\n              var neo4jError = _this5._handleProtocolError('Received FAILURE as a response for RESET: ' + error);\n\n              reject(neo4jError);\n            }\n          },\n          onCompleted: function onCompleted() {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_resetOnFailure\",\n    value: function _resetOnFailure() {\n      var _this6 = this;\n\n      this._protocol.reset({\n        onNext: function onNext(record) {\n          _this6._handleProtocolError('Received RECORD as a response for RESET: ' + JSON.stringify(record));\n        },\n        // clear the current failure when response for RESET is received\n        onError: function onError() {\n          _this6._currentFailure = null;\n        },\n        onCompleted: function onCompleted() {\n          _this6._currentFailure = null;\n        }\n      });\n    }\n  }, {\n    key: \"_queueObserver\",\n    value: function _queueObserver(observer) {\n      if (this._isBroken) {\n        if (observer && observer.onError) {\n          observer.onError(this._error);\n        }\n\n        return false;\n      }\n\n      observer = observer || NO_OP_OBSERVER;\n      observer.onCompleted = observer.onCompleted || NO_OP;\n      observer.onError = observer.onError || NO_OP;\n      observer.onNext = observer.onNext || NO_OP;\n\n      if (this._currentObserver === undefined) {\n        this._currentObserver = observer;\n      } else {\n        this._pendingObservers.push(observer);\n      }\n\n      return true;\n    }\n    /*\n     * Pop next pending observer form the list of observers and make it current observer.\n     * @protected\n     */\n\n  }, {\n    key: \"_updateCurrentObserver\",\n    value: function _updateCurrentObserver() {\n      this._currentObserver = this._pendingObservers.shift();\n    }\n    /** Check if this connection is in working condition */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return !this._isBroken && this._ch._open;\n    }\n    /**\n     * Call close on the channel.\n     * @param {function} cb - Function to call on close.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this7 = this;\n\n      var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return null;\n      };\n\n      if (this._log.isDebugEnabled()) {\n        this._log.debug(\"\".concat(this, \" closing\"));\n      }\n\n      if (this._protocol && this.isOpen()) {\n        // protocol has been initialized and this connection is healthy\n        // notify the database about the upcoming close of the connection\n        this._protocol.prepareToClose(NO_OP_OBSERVER);\n      }\n\n      this._ch.close(function () {\n        if (_this7._log.isDebugEnabled()) {\n          _this7._log.debug(\"\".concat(_this7, \" closed\"));\n        }\n\n        cb();\n      });\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var dbConnectionId = this._dbConnectionId || '';\n      return \"Connection [\".concat(this.id, \"][\").concat(dbConnectionId, \"]\");\n    }\n  }, {\n    key: \"_packable\",\n    value: function _packable(value) {\n      var _this8 = this;\n\n      return this._protocol.packer().packable(value, function (err) {\n        return _this8._handleFatalError(err);\n      });\n    }\n  }, {\n    key: \"_handleProtocolError\",\n    value: function _handleProtocolError(message) {\n      this._currentFailure = null;\n\n      this._updateCurrentObserver();\n\n      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);\n\n      this._handleFatalError(error);\n\n      return error;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(address, config, errorHandler, log) {\n      var channelConfig = new _channelConfig[\"default\"](address, config, errorHandler.errorCode());\n      return new Connection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers);\n    }\n  }]);\n  return Connection;\n}();\n\nexports[\"default\"] = Connection;\n\nvar InitializationObserver =\n/*#__PURE__*/\nfunction () {\n  function InitializationObserver(connection, onSuccess, onError) {\n    (0, _classCallCheck2[\"default\"])(this, InitializationObserver);\n    this._connection = connection;\n    this._onSuccess = onSuccess;\n    this._onError = onError;\n  }\n\n  (0, _createClass2[\"default\"])(InitializationObserver, [{\n    key: \"onNext\",\n    value: function onNext(record) {\n      this.onError((0, _error.newError)('Received RECORD when initializing ' + JSON.stringify(record)));\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      this._connection._updateCurrentObserver(); // make sure this exact observer will not be called again\n\n\n      this._connection._handleFatalError(error); // initialization errors are fatal\n\n\n      this._onError(error);\n    }\n  }, {\n    key: \"onCompleted\",\n    value: function onCompleted(metadata) {\n      if (metadata) {\n        // read server version from the response metadata, if it is available\n        var serverVersion = metadata.server;\n\n        if (!this._connection.server.version) {\n          this._connection.server.version = serverVersion;\n\n          var version = _serverVersion.ServerVersion.fromString(serverVersion);\n\n          if (version.compareTo(_serverVersion.VERSION_3_2_0) < 0) {\n            this._connection.protocol().packer().disableByteArrays();\n          }\n        } // read database connection id from the response metadata, if it is available\n\n\n        var dbConnectionId = metadata.connection_id;\n\n        if (!this._connection._dbConnectionId) {\n          this._connection._dbConnectionId = dbConnectionId;\n        }\n      }\n\n      this._onSuccess(this._connection);\n    }\n  }]);\n  return InitializationObserver;\n}();","map":null,"metadata":{},"sourceType":"script"}