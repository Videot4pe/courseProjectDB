{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _poolConfig = _interopRequireDefault(require(\"./pool-config\"));\n\nvar _error = require(\"../error\");\n\nvar _logger = _interopRequireDefault(require(\"./logger\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar Pool =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {function(function): Promise<object>} create  an allocation function that creates a promise with a new resource. It's given\n   *                a single argument, a function that will return the resource to\n   *                the pool if invoked, which is meant to be called on .dispose\n   *                or .close or whatever mechanism the resource uses to finalize.\n   * @param {function} destroy called with the resource when it is evicted from this pool\n   * @param {function} validate called at various times (like when an instance is acquired and\n   *                 when it is returned). If this returns false, the resource will\n   *                 be evicted\n   * @param {function} installIdleObserver called when the resource is released back to pool\n   * @param {function} removeIdleObserver called when the resource is acquired from the pool\n   * @param {PoolConfig} config configuration for the new driver.\n   * @param {Logger} log the driver logger.\n   */\n  function Pool() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$create = _ref.create,\n        create = _ref$create === void 0 ? function (address, release) {} : _ref$create,\n        _ref$destroy = _ref.destroy,\n        destroy = _ref$destroy === void 0 ? function (conn) {\n      return true;\n    } : _ref$destroy,\n        _ref$validate = _ref.validate,\n        validate = _ref$validate === void 0 ? function (conn) {\n      return true;\n    } : _ref$validate,\n        _ref$installIdleObser = _ref.installIdleObserver,\n        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,\n        _ref$removeIdleObserv = _ref.removeIdleObserver,\n        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? _poolConfig[\"default\"].defaultConfig() : _ref$config,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? _logger[\"default\"].noOp() : _ref$log;\n\n    (0, _classCallCheck2[\"default\"])(this, Pool);\n    this._create = create;\n    this._destroy = destroy;\n    this._validate = validate;\n    this._installIdleObserver = installIdleObserver;\n    this._removeIdleObserver = removeIdleObserver;\n    this._maxSize = config.maxSize;\n    this._acquisitionTimeout = config.acquisitionTimeout;\n    this._pools = {};\n    this._acquireRequests = {};\n    this._activeResourceCounts = {};\n    this._release = this._release.bind(this);\n    this._log = log;\n  }\n  /**\n   * Acquire and idle resource fom the pool or create a new one.\n   * @param {ServerAddress} address the address for which we're acquiring.\n   * @return {object} resource that is ready to use.\n   */\n\n\n  (0, _createClass2[\"default\"])(Pool, [{\n    key: \"acquire\",\n    value: function acquire(address) {\n      var _this = this;\n\n      return this._acquire(address).then(function (resource) {\n        var key = address.asKey();\n\n        if (resource) {\n          resourceAcquired(key, _this._activeResourceCounts);\n\n          if (_this._log.isDebugEnabled()) {\n            _this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(key));\n          }\n\n          return resource;\n        } // We're out of resources and will try to acquire later on when an existing resource is released.\n\n\n        var allRequests = _this._acquireRequests;\n        var requests = allRequests[key];\n\n        if (!requests) {\n          allRequests[key] = [];\n        }\n\n        return new Promise(function (resolve, reject) {\n          var request;\n          var timeoutId = setTimeout(function () {\n            // acquisition timeout fired\n            // remove request from the queue of pending requests, if it's still there\n            // request might've been taken out by the release operation\n            var pendingRequests = allRequests[key];\n\n            if (pendingRequests) {\n              allRequests[key] = pendingRequests.filter(function (item) {\n                return item !== request;\n              });\n            }\n\n            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do\n            } else {\n              // request is still pending and needs to be failed\n              request.reject((0, _error.newError)(\"Connection acquisition timed out in \".concat(_this._acquisitionTimeout, \" ms.\")));\n            }\n          }, _this._acquisitionTimeout);\n          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);\n          allRequests[key].push(request);\n        });\n      });\n    }\n    /**\n     * Destroy all idle resources for the given address.\n     * @param {ServerAddress} address the address of the server to purge its pool.\n     */\n\n  }, {\n    key: \"purge\",\n    value: function purge(address) {\n      this._purgeKey(address.asKey());\n    }\n    /**\n     * Destroy all idle resources in this pool.\n     */\n\n  }, {\n    key: \"purgeAll\",\n    value: function purgeAll() {\n      var _this2 = this;\n\n      Object.keys(this._pools).forEach(function (key) {\n        return _this2._purgeKey(key);\n      });\n    }\n    /**\n     * Keep the idle resources for the provided addresses and purge the rest.\n     */\n\n  }, {\n    key: \"keepAll\",\n    value: function keepAll(addresses) {\n      var _this3 = this;\n\n      var keysToKeep = addresses.map(function (a) {\n        return a.asKey();\n      });\n      var keysPresent = Object.keys(this._pools);\n      var keysToPurge = keysPresent.filter(function (k) {\n        return keysToKeep.indexOf(k) === -1;\n      });\n      keysToPurge.forEach(function (key) {\n        return _this3._purgeKey(key);\n      });\n    }\n    /**\n     * Check if this pool contains resources for the given address.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(address) {\n      return address.asKey() in this._pools;\n    }\n    /**\n     * Get count of active (checked out of the pool) resources for the given key.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {number} count of resources acquired by clients.\n     */\n\n  }, {\n    key: \"activeResourceCount\",\n    value: function activeResourceCount(address) {\n      return this._activeResourceCounts[address.asKey()] || 0;\n    }\n  }, {\n    key: \"_acquire\",\n    value: function _acquire(address) {\n      var key = address.asKey();\n      var pool = this._pools[key];\n\n      if (!pool) {\n        pool = [];\n        this._pools[key] = pool;\n      }\n\n      while (pool.length) {\n        var resource = pool.pop();\n\n        if (this._validate(resource)) {\n          if (this._removeIdleObserver) {\n            this._removeIdleObserver(resource);\n          } // idle resource is valid and can be acquired\n\n\n          return Promise.resolve(resource);\n        } else {\n          this._destroy(resource);\n        }\n      }\n\n      if (this._maxSize && this.activeResourceCount(address) >= this._maxSize) {\n        return Promise.resolve(null);\n      } // there exist no idle valid resources, create a new one for acquisition\n\n\n      return this._create(address, this._release);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(address, resource) {\n      var _this4 = this;\n\n      var key = address.asKey();\n      var pool = this._pools[key];\n\n      if (pool) {\n        // there exist idle connections for the given key\n        if (!this._validate(resource)) {\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because it is not functional\"));\n          }\n\n          this._destroy(resource);\n        } else {\n          if (this._log.isDebugEnabled()) {\n            this._log.debug(\"\".concat(resource, \" released to the pool \").concat(key));\n          }\n\n          if (this._installIdleObserver) {\n            this._installIdleObserver(resource, {\n              onError: function onError() {\n                var pool = _this4._pools[key];\n\n                if (pool) {\n                  _this4._pools[key] = pool.filter(function (r) {\n                    return r !== resource;\n                  });\n                }\n\n                _this4._destroy(resource);\n              }\n            });\n          }\n\n          pool.push(resource);\n        }\n      } else {\n        // key has been purged, don't put it back, just destroy the resource\n        if (this._log.isDebugEnabled()) {\n          this._log.debug(\"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because pool has been purged\"));\n        }\n\n        this._destroy(resource);\n      }\n\n      resourceReleased(key, this._activeResourceCounts);\n\n      this._processPendingAcquireRequests(address);\n    }\n  }, {\n    key: \"_purgeKey\",\n    value: function _purgeKey(key) {\n      var pool = this._pools[key] || [];\n\n      while (pool.length) {\n        var resource = pool.pop();\n\n        if (this._removeIdleObserver) {\n          this._removeIdleObserver(resource);\n        }\n\n        this._destroy(resource);\n      }\n\n      delete this._pools[key];\n    }\n  }, {\n    key: \"_processPendingAcquireRequests\",\n    value: function _processPendingAcquireRequests(address) {\n      var _this5 = this;\n\n      var key = address.asKey();\n      var requests = this._acquireRequests[key];\n\n      if (requests) {\n        var pendingRequest = requests.shift(); // pop a pending acquire request\n\n        if (pendingRequest) {\n          this._acquire(address)[\"catch\"](function (error) {\n            // failed to acquire/create a new connection to resolve the pending acquire request\n            // propagate the error by failing the pending request\n            pendingRequest.reject(error);\n            return null;\n          }).then(function (resource) {\n            if (resource) {\n              // managed to acquire a valid resource from the pool\n              if (pendingRequest.isCompleted()) {\n                // request has been completed, most likely failed by a timeout\n                // return the acquired resource back to the pool\n                _this5._release(address, resource);\n              } else {\n                // request is still pending and can be resolved with the newly acquired resource\n                resourceAcquired(key, _this5._activeResourceCounts); // increment the active counter\n\n                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource\n              }\n            }\n          });\n        } else {\n          delete this._acquireRequests[key];\n        }\n      }\n    }\n  }]);\n  return Pool;\n}();\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceAcquired(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\n\n\nfunction resourceReleased(key, activeResourceCounts) {\n  var currentCount = activeResourceCounts[key] || 0;\n  var nextCount = currentCount - 1;\n\n  if (nextCount > 0) {\n    activeResourceCounts[key] = nextCount;\n  } else {\n    delete activeResourceCounts[key];\n  }\n}\n\nvar PendingRequest =\n/*#__PURE__*/\nfunction () {\n  function PendingRequest(key, resolve, reject, timeoutId, log) {\n    (0, _classCallCheck2[\"default\"])(this, PendingRequest);\n    this._key = key;\n    this._resolve = resolve;\n    this._reject = reject;\n    this._timeoutId = timeoutId;\n    this._log = log;\n    this._completed = false;\n  }\n\n  (0, _createClass2[\"default\"])(PendingRequest, [{\n    key: \"isCompleted\",\n    value: function isCompleted() {\n      return this._completed;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(resource) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      if (this._log.isDebugEnabled()) {\n        this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(this._key));\n      }\n\n      this._resolve(resource);\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(error) {\n      if (this._completed) {\n        return;\n      }\n\n      this._completed = true;\n      clearTimeout(this._timeoutId);\n\n      this._reject(error);\n    }\n  }]);\n  return PendingRequest;\n}();\n\nvar _default = Pool;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}