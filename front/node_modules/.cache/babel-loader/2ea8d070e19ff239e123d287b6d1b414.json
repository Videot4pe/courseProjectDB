{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar BOOKMARK_KEY = 'bookmark';\nvar BOOKMARKS_KEY = 'bookmarks';\nvar BOOKMARK_PREFIX = 'neo4j:bookmark:v1:tx';\nvar UNKNOWN_BOOKMARK_VALUE = -1;\n\nvar Bookmark =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {string|string[]} values single bookmark as string or multiple bookmarks as a string array.\n   */\n  function Bookmark(values) {\n    (0, _classCallCheck2[\"default\"])(this, Bookmark);\n    this._values = asStringArray(values);\n    this._maxValue = maxBookmark(this._values);\n  }\n\n  (0, _createClass2[\"default\"])(Bookmark, [{\n    key: \"isEmpty\",\n\n    /**\n     * Check if the given bookmark is meaningful and can be send to the database.\n     * @return {boolean} returns `true` bookmark has a value, `false` otherwise.\n     */\n    value: function isEmpty() {\n      return this._maxValue === null;\n    }\n    /**\n     * Get maximum value of this bookmark as string.\n     * @return {string|null} the maximum value or `null` if it is not defined.\n     */\n\n  }, {\n    key: \"maxBookmarkAsString\",\n    value: function maxBookmarkAsString() {\n      return this._maxValue;\n    }\n    /**\n     * Get all bookmark values as an array.\n     * @return {string[]} all values.\n     */\n\n  }, {\n    key: \"values\",\n    value: function values() {\n      return this._values;\n    }\n    /**\n     * Get this bookmark as an object for begin transaction call.\n     * @return {object} the value of this bookmark as object.\n     */\n\n  }, {\n    key: \"asBeginTransactionParameters\",\n    value: function asBeginTransactionParameters() {\n      var _ref;\n\n      if (this.isEmpty()) {\n        return {};\n      } // Driver sends {bookmark: \"max\", bookmarks: [\"one\", \"two\", \"max\"]} instead of simple\n      // {bookmarks: [\"one\", \"two\", \"max\"]} for backwards compatibility reasons. Old servers can only accept single\n      // bookmark that is why driver has to parse and compare given list of bookmarks. This functionality will\n      // eventually be removed.\n\n\n      return _ref = {}, (0, _defineProperty2[\"default\"])(_ref, BOOKMARK_KEY, this._maxValue), (0, _defineProperty2[\"default\"])(_ref, BOOKMARKS_KEY, this._values), _ref;\n    }\n  }], [{\n    key: \"empty\",\n    value: function empty() {\n      return EMPTY_BOOKMARK;\n    }\n  }]);\n  return Bookmark;\n}();\n\nexports[\"default\"] = Bookmark;\nvar EMPTY_BOOKMARK = new Bookmark(null);\n/**\n * Converts given value to an array.\n * @param {string|string[]} [value=undefined] argument to convert.\n * @return {string[]} value converted to an array.\n */\n\nfunction asStringArray(value) {\n  if (!value) {\n    return [];\n  }\n\n  if (util.isString(value)) {\n    return [value];\n  }\n\n  if (Array.isArray(value)) {\n    var result = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var element = value[i]; // if it is undefined or null, ignore it\n\n      if (element !== undefined && element !== null) {\n        if (!util.isString(element)) {\n          throw new TypeError(\"Bookmark should be a string, given: '\".concat(element, \"'\"));\n        }\n\n        result.push(element);\n      }\n    }\n\n    return result;\n  }\n\n  throw new TypeError(\"Bookmark should either be a string or a string array, given: '\".concat(value, \"'\"));\n}\n/**\n * Find latest bookmark in the given array of bookmarks.\n * @param {string[]} bookmarks array of bookmarks.\n * @return {string|null} latest bookmark value.\n */\n\n\nfunction maxBookmark(bookmarks) {\n  if (!bookmarks || bookmarks.length === 0) {\n    return null;\n  }\n\n  var maxBookmark = bookmarks[0];\n  var maxValue = bookmarkValue(maxBookmark);\n\n  for (var i = 1; i < bookmarks.length; i++) {\n    var bookmark = bookmarks[i];\n    var value = bookmarkValue(bookmark);\n\n    if (value > maxValue) {\n      maxBookmark = bookmark;\n      maxValue = value;\n    }\n  }\n\n  return maxBookmark;\n}\n/**\n * Calculate numeric value for the given bookmark.\n * @param {string} bookmark argument to get numeric value for.\n * @return {number} value of the bookmark.\n */\n\n\nfunction bookmarkValue(bookmark) {\n  if (bookmark && bookmark.indexOf(BOOKMARK_PREFIX) === 0) {\n    var result = parseInt(bookmark.substring(BOOKMARK_PREFIX.length));\n    return result || UNKNOWN_BOOKMARK_VALUE;\n  }\n\n  return UNKNOWN_BOOKMARK_VALUE;\n}","map":null,"metadata":{},"sourceType":"script"}