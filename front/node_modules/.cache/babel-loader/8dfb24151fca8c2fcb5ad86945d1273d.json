{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EMPTY_CONNECTION_HOLDER = exports[\"default\"] = void 0;\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Utility to lazily initialize connections and return them back to the pool when unused.\n */\n\n\nvar ConnectionHolder =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {string} mode - the access mode for new connection holder.\n   * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.\n   */\n  function ConnectionHolder(mode, connectionProvider) {\n    (0, _classCallCheck2[\"default\"])(this, ConnectionHolder);\n    this._mode = mode;\n    this._connectionProvider = connectionProvider;\n    this._referenceCount = 0;\n    this._connectionPromise = Promise.resolve(null);\n  }\n  /**\n   * Returns the assigned access mode.\n   * @returns {string} access mode\n   */\n\n\n  (0, _createClass2[\"default\"])(ConnectionHolder, [{\n    key: \"mode\",\n    value: function mode() {\n      return this._mode;\n    }\n    /**\n     * Make this holder initialize new connection if none exists already.\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"initializeConnection\",\n    value: function initializeConnection() {\n      if (this._referenceCount === 0) {\n        this._connectionPromise = this._connectionProvider.acquireConnection(this._mode);\n      }\n\n      this._referenceCount++;\n    }\n    /**\n     * Get the current connection promise.\n     * @param {StreamObserver} streamObserver an observer for this connection.\n     * @return {Promise<Connection>} promise resolved with the current connection.\n     */\n\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(streamObserver) {\n      return this._connectionPromise.then(function (connection) {\n        streamObserver.resolveConnection(connection);\n        return connection;\n      });\n    }\n    /**\n     * Notify this holder that single party does not require current connection any more.\n     * @return {Promise<Connection>} promise resolved with the current connection, never a rejected promise.\n     */\n\n  }, {\n    key: \"releaseConnection\",\n    value: function releaseConnection() {\n      if (this._referenceCount === 0) {\n        return this._connectionPromise;\n      }\n\n      this._referenceCount--;\n\n      if (this._referenceCount === 0) {\n        return this._releaseConnection();\n      }\n\n      return this._connectionPromise;\n    }\n    /**\n     * Closes this holder and releases current connection (if any) despite any existing users.\n     * @return {Promise<Connection>} promise resolved when current connection is released to the pool.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._referenceCount === 0) {\n        return this._connectionPromise;\n      }\n\n      this._referenceCount = 0;\n      return this._releaseConnection();\n    }\n    /**\n     * Return the current pooled connection instance to the connection pool.\n     * We don't pool Session instances, to avoid users using the Session after they've called close.\n     * The `Session` object is just a thin wrapper around Connection anyway, so it makes little difference.\n     * @return {Promise} - promise resolved then connection is returned to the pool.\n     * @private\n     */\n\n  }, {\n    key: \"_releaseConnection\",\n    value: function _releaseConnection() {\n      this._connectionPromise = this._connectionPromise.then(function (connection) {\n        if (connection) {\n          return connection.resetAndFlush()[\"catch\"](ignoreError).then(function () {\n            return connection._release();\n          });\n        } else {\n          return Promise.resolve();\n        }\n      })[\"catch\"](ignoreError);\n      return this._connectionPromise;\n    }\n  }]);\n  return ConnectionHolder;\n}();\n\nexports[\"default\"] = ConnectionHolder;\n\nvar EmptyConnectionHolder =\n/*#__PURE__*/\nfunction (_ConnectionHolder) {\n  (0, _inherits2[\"default\"])(EmptyConnectionHolder, _ConnectionHolder);\n\n  function EmptyConnectionHolder() {\n    (0, _classCallCheck2[\"default\"])(this, EmptyConnectionHolder);\n    return (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(EmptyConnectionHolder).apply(this, arguments));\n  }\n\n  (0, _createClass2[\"default\"])(EmptyConnectionHolder, [{\n    key: \"initializeConnection\",\n    value: function initializeConnection() {// nothing to initialize\n    }\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(streamObserver) {\n      return Promise.reject((0, _error.newError)('This connection holder does not serve connections'));\n    }\n  }, {\n    key: \"releaseConnection\",\n    value: function releaseConnection() {\n      return Promise.resolve();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n  }]);\n  return EmptyConnectionHolder;\n}(ConnectionHolder);\n\nfunction ignoreError() {}\n/**\n * Connection holder that does not manage any connections.\n * @type {ConnectionHolder}\n */\n\n\nvar EMPTY_CONNECTION_HOLDER = new EmptyConnectionHolder();\nexports.EMPTY_CONNECTION_HOLDER = EMPTY_CONNECTION_HOLDER;","map":null,"metadata":{},"sourceType":"script"}