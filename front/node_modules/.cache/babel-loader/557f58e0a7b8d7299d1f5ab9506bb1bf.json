{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _resultSummary = _interopRequireDefault(require(\"./result-summary\"));\n\nvar _connectionHolder = require(\"./internal/connection-holder\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {\n  console.log('Uncaught error when processing result: ' + error);\n};\n\nvar DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};\n/**\n * A stream of {@link Record} representing the result of a statement.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\n\n\nvar Result =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Inject the observer to be used.\n   * @constructor\n   * @access private\n   * @param {StreamObserver} streamObserver\n   * @param {mixed} statement - Cypher statement to execute\n   * @param {Object} parameters - Map with parameters to use in statement\n   * @param metaSupplier function, when called provides metadata\n   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n   */\n  function Result(streamObserver, statement, parameters, metaSupplier, connectionHolder) {\n    (0, _classCallCheck2[\"default\"])(this, Result);\n    this._stack = captureStacktrace();\n    this._streamObserver = streamObserver;\n    this._p = null;\n    this._statement = statement;\n    this._parameters = parameters || {};\n\n    this._metaSupplier = metaSupplier || function () {\n      return {};\n    };\n\n    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;\n  }\n  /**\n   * Create and return new Promise\n   * @return {Promise} new Promise.\n   * @access private\n   */\n\n\n  (0, _createClass2[\"default\"])(Result, [{\n    key: \"_createPromise\",\n    value: function _createPromise() {\n      if (this._p) {\n        return;\n      }\n\n      var self = this;\n      this._p = new Promise(function (resolve, reject) {\n        var records = [];\n        var observer = {\n          onNext: function onNext(record) {\n            records.push(record);\n          },\n          onCompleted: function onCompleted(summary) {\n            resolve({\n              records: records,\n              summary: summary\n            });\n          },\n          onError: function onError(error) {\n            reject(error);\n          }\n        };\n        self.subscribe(observer);\n      });\n    }\n    /**\n     * Waits for all results and calls the passed in function with the results.\n     * Cannot be combined with the {@link Result#subscribe} function.\n     *\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n     * when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(onFulfilled, onRejected) {\n      this._createPromise();\n\n      return this._p.then(onFulfilled, onRejected);\n    }\n    /**\n     * Catch errors when using promises.\n     * Cannot be used with the subscribe function.\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n\n  }, {\n    key: \"catch\",\n    value: function _catch(onRejected) {\n      this._createPromise();\n\n      return this._p[\"catch\"](onRejected);\n    }\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @param {Object} observer - Observer object\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n     * @return\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      var _this = this;\n\n      var self = this;\n      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n\n      var onCompletedWrapper = function onCompletedWrapper(metadata) {\n        var additionalMeta = self._metaSupplier();\n\n        for (var key in additionalMeta) {\n          if (additionalMeta.hasOwnProperty(key)) {\n            metadata[key] = additionalMeta[key];\n          }\n        }\n\n        var sum = new _resultSummary[\"default\"](_this._statement, _this._parameters, metadata); // notify connection holder that the used connection is not needed any more because result has\n        // been fully consumed; call the original onCompleted callback after that\n\n        self._connectionHolder.releaseConnection().then(function () {\n          onCompletedOriginal.call(observer, sum);\n        });\n      };\n\n      observer.onCompleted = onCompletedWrapper;\n      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n\n      var onErrorWrapper = function onErrorWrapper(error) {\n        // notify connection holder that the used connection is not needed any more because error happened\n        // and result can't bee consumed any further; call the original onError callback after that\n        self._connectionHolder.releaseConnection().then(function () {\n          replaceStacktrace(error, _this._stack);\n          onErrorOriginal.call(observer, error);\n        });\n      };\n\n      observer.onError = onErrorWrapper;\n\n      this._streamObserver.subscribe(observer);\n    }\n  }]);\n  return Result;\n}();\n\nfunction captureStacktrace() {\n  var error = new Error('');\n\n  if (error.stack) {\n    return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n  }\n\n  return null;\n}\n\nfunction replaceStacktrace(error, newStack) {\n  if (newStack) {\n    // Error.prototype.toString() concatenates error.name and error.message nicely\n    // then we add the rest of the stack trace\n    error.stack = error.toString() + '\\n' + newStack;\n  }\n}\n\nvar _default = Result;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}