{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _construct2 = _interopRequireDefault(require(\"@babel/runtime/helpers/construct\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _integer = require(\"../../integer\");\n\nvar _graphTypes = require(\"../../graph-types\");\n\nvar _error = require(\"../../error\");\n\nvar _spatialTypes = require(\"../../spatial-types\");\n\nvar _temporalTypes = require(\"../../temporal-types\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar CREDENTIALS_EXPIRED_CODE = 'Neo.ClientError.Security.CredentialsExpired';\n\nvar HttpResponseConverter =\n/*#__PURE__*/\nfunction () {\n  function HttpResponseConverter() {\n    (0, _classCallCheck2[\"default\"])(this, HttpResponseConverter);\n  }\n\n  (0, _createClass2[\"default\"])(HttpResponseConverter, [{\n    key: \"encodeStatementParameters\",\n    value: function encodeStatementParameters(parameters) {\n      return encodeQueryParameters(parameters);\n    }\n    /**\n     * Attempts to extract error from transactional cypher endpoint response and convert it to {@link Neo4jError}.\n     * @param {object} response the response.\n     * @return {Neo4jError|null} new driver friendly error, if exists.\n     */\n\n  }, {\n    key: \"extractError\",\n    value: function extractError(response) {\n      var errors = response.errors;\n\n      if (errors) {\n        var error = errors[0];\n\n        if (error) {\n          // endpoint returns 'Neo.ClientError.Security.Forbidden' code and 'password_change' that points to another endpoint\n          // this is different from code returned via Bolt and less descriptive\n          // make code same as in Bolt, if password change is required\n          var code = response.password_change ? CREDENTIALS_EXPIRED_CODE : error.code;\n          var message = error.message;\n          return new _error.Neo4jError(message, code);\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Extracts transaction id from the db/data/transaction endpoint response.\n     * @param {object} response the response.\n     * @return {number} the transaction id.\n     */\n\n  }, {\n    key: \"extractTransactionId\",\n    value: function extractTransactionId(response) {\n      var commitUrl = response.commit;\n\n      if (commitUrl) {\n        // extract id 42 from commit url like 'http://localhost:7474/db/data/transaction/42/commit'\n        var url = commitUrl.replace('/commit', '');\n        var transactionIdString = url.substring(url.lastIndexOf('/') + 1);\n        var transactionId = parseInt(transactionIdString, 10);\n\n        if (transactionId || transactionId === 0) {\n          return transactionId;\n        }\n      }\n\n      throw new _error.Neo4jError(\"Unable to extract transaction id from the response JSON: \".concat(JSON.stringify(response)));\n    }\n    /**\n     * Extracts record metadata (array of column names) from transactional cypher endpoint response.\n     * @param {object} response the response.\n     * @return {object} new metadata object.\n     */\n\n  }, {\n    key: \"extractRecordMetadata\",\n    value: function extractRecordMetadata(response) {\n      var result = extractResult(response);\n      var fields = result ? result.columns : [];\n      return {\n        fields: fields\n      };\n    }\n    /**\n     * Extracts raw records (each raw record is just an array of value) from transactional cypher endpoint response.\n     * @param {object} response the response.\n     * @return {object[][]} raw records from the response.\n     */\n\n  }, {\n    key: \"extractRawRecords\",\n    value: function extractRawRecords(response) {\n      var result = extractResult(response);\n\n      if (result) {\n        var data = result.data;\n\n        if (data) {\n          return data.map(function (element) {\n            return extractRawRecord(element);\n          });\n        }\n      }\n\n      return [];\n    }\n    /**\n     * Extracts metadata for a completed statement.\n     * @param {object} response the response.\n     * @return {object} metadata as object.\n     */\n\n  }, {\n    key: \"extractStatementMetadata\",\n    value: function extractStatementMetadata(response) {\n      var result = extractResult(response);\n\n      if (result) {\n        var stats = result.stats;\n\n        if (stats) {\n          var convertedStats = Object.keys(stats).reduce(function (newStats, key) {\n            if (key === 'contains_updates') {\n              // skip because such key does not exist in bolt\n              return newStats;\n            } // fix key name for future parsing by StatementStatistics class\n\n\n            var newKey = (key === 'relationship_deleted' ? 'relationships_deleted' : key).replace('_', '-');\n            newStats[newKey] = stats[key];\n            return newStats;\n          }, {});\n          return {\n            stats: convertedStats\n          };\n        }\n      }\n\n      return {};\n    }\n  }]);\n  return HttpResponseConverter;\n}();\n\nexports[\"default\"] = HttpResponseConverter;\n\nfunction encodeQueryParameters(parameters) {\n  if (parameters && (0, _typeof2[\"default\"])(parameters) === 'object') {\n    return Object.keys(parameters).reduce(function (result, key) {\n      result[key] = encodeQueryParameter(parameters[key]);\n      return result;\n    }, {});\n  }\n\n  return parameters;\n}\n\nfunction encodeQueryParameter(value) {\n  if (value instanceof _graphTypes.Node) {\n    throw new _error.Neo4jError('It is not allowed to pass nodes in query parameters', _error.PROTOCOL_ERROR);\n  } else if (value instanceof _graphTypes.Relationship) {\n    throw new _error.Neo4jError('It is not allowed to pass relationships in query parameters', _error.PROTOCOL_ERROR);\n  } else if (value instanceof _graphTypes.Path) {\n    throw new _error.Neo4jError('It is not allowed to pass paths in query parameters', _error.PROTOCOL_ERROR);\n  } else if ((0, _spatialTypes.isPoint)(value)) {\n    throw newUnsupportedParameterError('points');\n  } else if ((0, _temporalTypes.isDate)(value)) {\n    throw newUnsupportedParameterError('dates');\n  } else if ((0, _temporalTypes.isDateTime)(value)) {\n    throw newUnsupportedParameterError('date-time');\n  } else if ((0, _temporalTypes.isDuration)(value)) {\n    throw newUnsupportedParameterError('durations');\n  } else if ((0, _temporalTypes.isLocalDateTime)(value)) {\n    throw newUnsupportedParameterError('local date-time');\n  } else if ((0, _temporalTypes.isLocalTime)(value)) {\n    throw newUnsupportedParameterError('local time');\n  } else if ((0, _temporalTypes.isTime)(value)) {\n    throw newUnsupportedParameterError('time');\n  } else if ((0, _integer.isInt)(value)) {\n    return value.toNumber();\n  } else if (Array.isArray(value)) {\n    return value.map(function (element) {\n      return encodeQueryParameter(element);\n    });\n  } else if ((0, _typeof2[\"default\"])(value) === 'object') {\n    return encodeQueryParameters(value);\n  } else {\n    return value;\n  }\n}\n\nfunction newUnsupportedParameterError(name) {\n  return new _error.Neo4jError(\"It is not allowed to pass \".concat(name, \" in query parameters when using HTTP endpoint. \") + \"Please consider using Cypher functions to create \".concat(name, \" so that query parameters are plain objects.\"), _error.PROTOCOL_ERROR);\n}\n\nfunction extractResult(response) {\n  var results = response.results;\n\n  if (results) {\n    var result = results[0];\n\n    if (result) {\n      return result;\n    }\n  }\n\n  return null;\n}\n\nfunction extractRawRecord(data) {\n  var row = data.row;\n  var nodesById = indexNodesById(data);\n  var relationshipsById = indexRelationshipsById(data);\n\n  if (row) {\n    return row.map(function (ignore, index) {\n      return extractRawRecordElement(index, data, nodesById, relationshipsById);\n    });\n  }\n\n  return [];\n}\n\nfunction indexNodesById(data) {\n  var graph = data.graph;\n\n  if (graph) {\n    var nodes = graph.nodes;\n\n    if (nodes) {\n      return nodes.reduce(function (result, node) {\n        var identity = convertNumber(node.id);\n        var labels = node.labels;\n        var properties = convertPrimitiveValue(node.properties);\n        result[node.id] = new _graphTypes.Node(identity, labels, properties);\n        return result;\n      }, {});\n    }\n  }\n\n  return {};\n}\n\nfunction indexRelationshipsById(data) {\n  var graph = data.graph;\n\n  if (graph) {\n    var relationships = graph.relationships;\n\n    if (relationships) {\n      return relationships.reduce(function (result, relationship) {\n        var identity = convertNumber(relationship.id);\n        var startNode = convertNumber(relationship.startNode);\n        var endNode = convertNumber(relationship.endNode);\n        var type = relationship.type;\n        var properties = convertPrimitiveValue(relationship.properties);\n        result[relationship.id] = new _graphTypes.Relationship(identity, startNode, endNode, type, properties);\n        return result;\n      }, {});\n    }\n  }\n\n  return {};\n}\n\nfunction extractRawRecordElement(index, data, nodesById, relationshipsById) {\n  var element = data.row ? data.row[index] : null;\n  var elementMetadata = data.meta ? data.meta[index] : null;\n\n  if (elementMetadata) {\n    // element is either a graph, spatial or temporal type\n    return convertComplexValue(element, elementMetadata, nodesById, relationshipsById);\n  } else {\n    // element is a primitive, like number, string, array or object\n    return convertPrimitiveValue(element);\n  }\n}\n\nfunction convertComplexValue(element, elementMetadata, nodesById, relationshipsById) {\n  if (isNodeMetadata(elementMetadata)) {\n    return nodesById[elementMetadata.id];\n  } else if (isRelationshipMetadata(elementMetadata)) {\n    return relationshipsById[elementMetadata.id];\n  } else if (isPathMetadata(elementMetadata)) {\n    return convertPath(elementMetadata, nodesById, relationshipsById);\n  } else if (isPointMetadata(elementMetadata)) {\n    return convertPoint(element);\n  } else {\n    return element;\n  }\n}\n\nfunction convertPath(metadata, nodesById, relationshipsById) {\n  var startNode = null;\n  var relationship = null;\n  var pathSegments = [];\n\n  for (var i = 0; i < metadata.length; i++) {\n    var element = metadata[i];\n    var elementId = element.id;\n    var elementType = element.type;\n    var nodeExpected = startNode === null && relationship === null || startNode !== null && relationship !== null;\n\n    if (nodeExpected && elementType !== 'node') {\n      throw new _error.Neo4jError(\"Unable to parse path, node expected but got: \".concat(JSON.stringify(element), \" in \").concat(JSON.stringify(metadata)));\n    }\n\n    if (!nodeExpected && elementType === 'node') {\n      throw new _error.Neo4jError(\"Unable to parse path, relationship expected but got: \".concat(JSON.stringify(element), \" in \").concat(JSON.stringify(metadata)));\n    }\n\n    if (nodeExpected) {\n      var node = nodesById[elementId];\n\n      if (startNode === null) {\n        startNode = node;\n      } else if (startNode !== null && relationship !== null) {\n        var pathSegment = new _graphTypes.PathSegment(startNode, relationship, node);\n        pathSegments.push(pathSegment);\n        startNode = node;\n        relationship = null;\n      } else {\n        throw new _error.Neo4jError(\"Unable to parse path, illegal node configuration: \".concat(JSON.stringify(metadata)));\n      }\n    } else {\n      if (relationship === null) {\n        relationship = relationshipsById[elementId];\n      } else {\n        throw new _error.Neo4jError(\"Unable to parse path, illegal relationship configuration: \".concat(JSON.stringify(metadata)));\n      }\n    }\n  }\n\n  var lastPathSegment = pathSegments[pathSegments.length - 1];\n\n  if (lastPathSegment && lastPathSegment.end !== startNode || relationship !== null) {\n    throw new _error.Neo4jError(\"Unable to parse path: \".concat(JSON.stringify(metadata)));\n  }\n\n  return createPath(pathSegments);\n}\n\nfunction createPath(pathSegments) {\n  var pathStartNode = pathSegments[0].start;\n  var pathEndNode = pathSegments[pathSegments.length - 1].end;\n  return new _graphTypes.Path(pathStartNode, pathEndNode, pathSegments);\n}\n\nfunction convertPoint(element) {\n  var type = element.type;\n\n  if (type !== 'Point') {\n    throw new _error.Neo4jError(\"Unexpected Point type received: \".concat(JSON.stringify(element)));\n  }\n\n  var coordinates = element.coordinates;\n\n  if (!Array.isArray(coordinates) && (coordinates.length !== 2 || coordinates.length !== 3)) {\n    throw new _error.Neo4jError(\"Unexpected Point coordinates received: \".concat(JSON.stringify(element)));\n  }\n\n  var srid = convertCrsToId(element);\n  return (0, _construct2[\"default\"])(_spatialTypes.Point, [srid].concat((0, _toConsumableArray2[\"default\"])(coordinates)));\n}\n\nfunction convertCrsToId(element) {\n  var crs = element.crs;\n\n  if (!crs || !crs.name) {\n    throw new _error.Neo4jError(\"Unexpected Point crs received: \".concat(JSON.stringify(element)));\n  }\n\n  var name = crs.name.toLowerCase();\n\n  if (name === 'wgs-84') {\n    return 4326;\n  } else if (name === 'wgs-84-3d') {\n    return 4979;\n  } else if (name === 'cartesian') {\n    return 7203;\n  } else if (name === 'cartesian-3d') {\n    return 9157;\n  } else {\n    throw new _error.Neo4jError(\"Unexpected Point crs received: \".concat(JSON.stringify(element)));\n  }\n}\n\nfunction convertPrimitiveValue(element) {\n  if (element == null || element === undefined) {\n    return null;\n  } else if (typeof element === 'number') {\n    return convertNumber(element);\n  } else if (Array.isArray(element)) {\n    return element.map(function (element) {\n      return convertPrimitiveValue(element);\n    });\n  } else if ((0, _typeof2[\"default\"])(element) === 'object') {\n    return Object.keys(element).reduce(function (result, key) {\n      result[key] = convertPrimitiveValue(element[key]);\n      return result;\n    }, {});\n  } else {\n    return element;\n  }\n}\n\nfunction convertNumber(value) {\n  return typeof value === 'number' ? value : Number(value);\n}\n\nfunction isNodeMetadata(metadata) {\n  return isMetadataForType('node', metadata);\n}\n\nfunction isRelationshipMetadata(metadata) {\n  return isMetadataForType('relationship', metadata);\n}\n\nfunction isPointMetadata(metadata) {\n  return isMetadataForType('point', metadata);\n}\n\nfunction isMetadataForType(name, metadata) {\n  return !Array.isArray(metadata) && (0, _typeof2[\"default\"])(metadata) === 'object' && metadata.type === name;\n}\n\nfunction isPathMetadata(metadata) {\n  return Array.isArray(metadata);\n}","map":null,"metadata":{},"sourceType":"script"}