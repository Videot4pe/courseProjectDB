{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _streamObserver = _interopRequireDefault(require(\"../stream-observer\"));\n\nvar _httpResponseConverter = _interopRequireDefault(require(\"./http-response-converter\"));\n\nvar _error = require(\"../../error\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar HttpRequestRunner =\n/*#__PURE__*/\nfunction () {\n  function HttpRequestRunner(url, authToken) {\n    (0, _classCallCheck2[\"default\"])(this, HttpRequestRunner);\n    this._url = url;\n    this._authToken = authToken;\n    this._converter = new _httpResponseConverter[\"default\"]();\n  }\n  /**\n   * Send a HTTP request to begin a transaction.\n   * @return {Promise<number>} promise resolved with the transaction id or rejected with an error.\n   */\n\n\n  (0, _createClass2[\"default\"])(HttpRequestRunner, [{\n    key: \"beginTransaction\",\n    value: function beginTransaction() {\n      var _this = this;\n\n      var url = beginTransactionUrl(this._url);\n      return sendRequest('POST', url, null, this._authToken).then(function (responseJson) {\n        var neo4jError = _this._converter.extractError(responseJson);\n\n        if (neo4jError) {\n          throw neo4jError;\n        }\n\n        return _this._converter.extractTransactionId(responseJson);\n      });\n    }\n    /**\n     * Send a HTTP request to commit a transaction.\n     * @param {number} transactionId id of the transaction to commit.\n     * @return {Promise<void>} promise resolved if transaction got committed or rejected when commit failed.\n     */\n\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(transactionId) {\n      var _this2 = this;\n\n      var url = commitTransactionUrl(this._url, transactionId);\n      return sendRequest('POST', url, null, this._authToken).then(function (responseJson) {\n        var neo4jError = _this2._converter.extractError(responseJson);\n\n        if (neo4jError) {\n          throw neo4jError;\n        }\n      });\n    }\n    /**\n     * Send a HTTP request to rollback a transaction.\n     * @param {number} transactionId id of the transaction to rollback.\n     * @return {Promise<void>} promise resolved if transaction got rolled back or rejected when rollback failed.\n     */\n\n  }, {\n    key: \"rollbackTransaction\",\n    value: function rollbackTransaction(transactionId) {\n      var _this3 = this;\n\n      var url = transactionUrl(this._url, transactionId);\n      return sendRequest('DELETE', url, null, this._authToken).then(function (responseJson) {\n        var neo4jError = _this3._converter.extractError(responseJson);\n\n        if (neo4jError) {\n          throw neo4jError;\n        }\n      });\n    }\n    /**\n     * Send a HTTP request to execute a query in a transaction with the given id.\n     * @param {number} transactionId the transaction id.\n     * @param {string} statement the cypher query.\n     * @param {object} parameters the cypher query parameters.\n     * @return {Promise<StreamObserver>} a promise resolved with {@link StreamObserver} containing either records or error.\n     */\n\n  }, {\n    key: \"runQuery\",\n    value: function runQuery(transactionId, statement, parameters) {\n      var _this4 = this;\n\n      var streamObserver = new _streamObserver[\"default\"]();\n      var url = transactionUrl(this._url, transactionId);\n      var body = createStatementJson(statement, parameters, this._converter, streamObserver);\n\n      if (!body) {\n        // unable to encode given statement and parameters, return a failed stream observer\n        return Promise.resolve(streamObserver);\n      }\n\n      return sendRequest('POST', url, body, this._authToken).then(function (responseJson) {\n        processResponseJson(responseJson, _this4._converter, streamObserver);\n      })[\"catch\"](function (error) {\n        streamObserver.onError(error);\n      }).then(function () {\n        return streamObserver;\n      });\n    }\n  }]);\n  return HttpRequestRunner;\n}();\n\nexports[\"default\"] = HttpRequestRunner;\n\nfunction sendRequest(method, url, bodyString, authToken) {\n  try {\n    var options = {\n      method: method,\n      headers: createHttpHeaders(authToken),\n      body: bodyString\n    };\n    return new Promise(function (resolve, reject) {\n      fetch(url, options).then(function (response) {\n        return response.json();\n      }).then(function (responseJson) {\n        return resolve(responseJson);\n      })[\"catch\"](function (error) {\n        return reject(new _error.Neo4jError(error.message, _error.SERVICE_UNAVAILABLE));\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\nfunction createHttpHeaders(authToken) {\n  var headers = new Headers();\n  headers.append('Accept', 'application/json; charset=UTF-8');\n  headers.append('Content-Type', 'application/json');\n  headers.append('Authorization', 'Basic ' + btoa(authToken.principal + ':' + authToken.credentials));\n  return headers;\n}\n\nfunction createStatementJson(statement, parameters, converter, streamObserver) {\n  try {\n    return createStatementJsonOrThrow(statement, parameters, converter);\n  } catch (e) {\n    streamObserver.onError(e);\n    return null;\n  }\n}\n\nfunction createStatementJsonOrThrow(statement, parameters, converter) {\n  var encodedParameters = converter.encodeStatementParameters(parameters);\n  return JSON.stringify({\n    statements: [{\n      statement: statement,\n      parameters: encodedParameters,\n      resultDataContents: ['row', 'graph'],\n      includeStats: true\n    }]\n  });\n}\n\nfunction processResponseJson(responseJson, converter, streamObserver) {\n  if (!responseJson) {\n    // request failed and there is no response\n    return;\n  }\n\n  try {\n    processResponseJsonOrThrow(responseJson, converter, streamObserver);\n  } catch (e) {\n    streamObserver.onError(e);\n  }\n}\n\nfunction processResponseJsonOrThrow(responseJson, converter, streamObserver) {\n  var neo4jError = converter.extractError(responseJson);\n\n  if (neo4jError) {\n    streamObserver.onError(neo4jError);\n  } else {\n    var recordMetadata = converter.extractRecordMetadata(responseJson);\n    streamObserver.onCompleted(recordMetadata);\n    var rawRecords = converter.extractRawRecords(responseJson);\n    rawRecords.forEach(function (rawRecord) {\n      return streamObserver.onNext(rawRecord);\n    });\n    var statementMetadata = converter.extractStatementMetadata(responseJson);\n    streamObserver.onCompleted(statementMetadata);\n  }\n}\n\nfunction beginTransactionUrl(baseUrl) {\n  return createUrl(baseUrl, '/db/data/transaction');\n}\n\nfunction commitTransactionUrl(baseUrl, transactionId) {\n  return transactionUrl(baseUrl, transactionId) + '/commit';\n}\n\nfunction transactionUrl(baseUrl, transactionId) {\n  return beginTransactionUrl(baseUrl) + '/' + transactionId;\n}\n\nfunction createUrl(baseUrl, path) {\n  return \"\".concat(baseUrl.scheme, \"://\").concat(baseUrl.host, \":\").concat(baseUrl.port).concat(path);\n}","map":null,"metadata":{},"sourceType":"script"}