{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _routingTable = _interopRequireDefault(require(\"./routing-table\"));\n\nvar _error = require(\"../error\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar Rediscovery =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {RoutingUtil} routingUtil the util to use.\n   */\n  function Rediscovery(routingUtil) {\n    (0, _classCallCheck2[\"default\"])(this, Rediscovery);\n    this._routingUtil = routingUtil;\n  }\n  /**\n   * Try to fetch new routing table from the given router.\n   * @param {Session} session the session to use.\n   * @param {string} routerAddress the URL of the router.\n   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.\n   */\n\n\n  (0, _createClass2[\"default\"])(Rediscovery, [{\n    key: \"lookupRoutingTableOnRouter\",\n    value: function lookupRoutingTableOnRouter(session, routerAddress) {\n      var _this = this;\n\n      return this._routingUtil.callRoutingProcedure(session, routerAddress).then(function (records) {\n        if (records === null) {\n          // connection error happened, unable to retrieve routing table from this router, next one should be queried\n          return null;\n        }\n\n        if (records.length !== 1) {\n          throw (0, _error.newError)('Illegal response from router \"' + routerAddress + '\". ' + 'Received ' + records.length + ' records but expected only one.\\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);\n        }\n\n        var record = records[0];\n\n        var expirationTime = _this._routingUtil.parseTtl(record, routerAddress);\n\n        var _this$_routingUtil$pa = _this._routingUtil.parseServers(record, routerAddress),\n            routers = _this$_routingUtil$pa.routers,\n            readers = _this$_routingUtil$pa.readers,\n            writers = _this$_routingUtil$pa.writers;\n\n        Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);\n\n        Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows\n        // how to deal with such table and how to treat router that returned such table\n\n\n        return new _routingTable[\"default\"](routers, readers, writers, expirationTime);\n      });\n    }\n  }], [{\n    key: \"_assertNonEmpty\",\n    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n      if (serverAddressesArray.length === 0) {\n        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);\n      }\n    }\n  }]);\n  return Rediscovery;\n}();\n\nexports[\"default\"] = Rediscovery;","map":null,"metadata":{},"sourceType":"script"}