{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _record = _interopRequireDefault(require(\"../record\"));\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Handles a RUN/PULL_ALL, or RUN/DISCARD_ALL requests, maps the responses\n * in a way that a user-provided observer can see these as a clean Stream\n * of records.\n * This class will queue up incoming messages until a user-provided observer\n * for the incoming stream is registered. Thus, we keep fields around\n * for tracking head/records/tail. These are only used if there is no\n * observer registered.\n * @access private\n */\n\n\nvar StreamObserver =\n/*#__PURE__*/\nfunction () {\n  function StreamObserver() {\n    (0, _classCallCheck2[\"default\"])(this, StreamObserver);\n    this._fieldKeys = null;\n    this._fieldLookup = null;\n    this._queuedRecords = [];\n    this._tail = null;\n    this._error = null;\n    this._hasFailed = false;\n    this._observer = null;\n    this._conn = null;\n    this._meta = {};\n  }\n  /**\n   * Will be called on every record that comes in and transform a raw record\n   * to a Object. If user-provided observer is present, pass transformed record\n   * to it's onNext method, otherwise, push to record que.\n   * @param {Array} rawRecord - An array with the raw record\n   */\n\n\n  (0, _createClass2[\"default\"])(StreamObserver, [{\n    key: \"onNext\",\n    value: function onNext(rawRecord) {\n      var record = new _record[\"default\"](this._fieldKeys, rawRecord, this._fieldLookup);\n\n      if (this._observer) {\n        this._observer.onNext(record);\n      } else {\n        this._queuedRecords.push(record);\n      }\n    }\n  }, {\n    key: \"onCompleted\",\n    value: function onCompleted(meta) {\n      if (this._fieldKeys === null) {\n        // Stream header, build a name->index field lookup table\n        // to be used by records. This is an optimization to make it\n        // faster to look up fields in a record by name, rather than by index.\n        // Since the records we get back via Bolt are just arrays of values.\n        this._fieldKeys = [];\n        this._fieldLookup = {};\n\n        if (meta.fields && meta.fields.length > 0) {\n          this._fieldKeys = meta.fields;\n\n          for (var i = 0; i < meta.fields.length; i++) {\n            this._fieldLookup[meta.fields[i]] = i;\n          }\n        }\n      } else {\n        // End of stream\n        if (this._observer) {\n          this._observer.onCompleted(meta);\n        } else {\n          this._tail = meta;\n        }\n      }\n\n      this._copyMetadataOnCompletion(meta);\n    }\n  }, {\n    key: \"_copyMetadataOnCompletion\",\n    value: function _copyMetadataOnCompletion(meta) {\n      for (var key in meta) {\n        if (meta.hasOwnProperty(key)) {\n          this._meta[key] = meta[key];\n        }\n      }\n    }\n  }, {\n    key: \"serverMetadata\",\n    value: function serverMetadata() {\n      var serverMeta = {\n        server: this._conn.server\n      };\n      return Object.assign({}, this._meta, serverMeta);\n    }\n  }, {\n    key: \"resolveConnection\",\n    value: function resolveConnection(conn) {\n      this._conn = conn;\n    }\n    /**\n     * Stream observer defaults to handling responses for two messages: RUN + PULL_ALL or RUN + DISCARD_ALL.\n     * Response for RUN initializes statement keys. Response for PULL_ALL / DISCARD_ALL exposes the result stream.\n     *\n     * However, some operations can be represented as a single message which receives full metadata in a single response.\n     * For example, operations to begin, commit and rollback an explicit transaction use two messages in Bolt V1 but a single message in Bolt V3.\n     * Messages are `RUN \"BEGIN\" {}` + `PULL_ALL` in Bolt V1 and `BEGIN` in Bolt V3.\n     *\n     * This function prepares the observer to only handle a single response message.\n     */\n\n  }, {\n    key: \"prepareToHandleSingleResponse\",\n    value: function prepareToHandleSingleResponse() {\n      this._fieldKeys = [];\n    }\n    /**\n     * Mark this observer as if it has completed with no metadata.\n     */\n\n  }, {\n    key: \"markCompleted\",\n    value: function markCompleted() {\n      this._fieldKeys = [];\n      this._tail = {};\n    }\n    /**\n     * Will be called on errors.\n     * If user-provided observer is present, pass the error\n     * to it's onError method, otherwise set instance variable _error.\n     * @param {Object} error - An error object\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      if (this._hasFailed) {\n        return;\n      }\n\n      this._hasFailed = true;\n\n      if (this._observer) {\n        if (this._observer.onError) {\n          this._observer.onError(error);\n        } else {\n          console.log(error);\n        }\n      } else {\n        this._error = error;\n      }\n    }\n    /**\n     * Subscribe to events with provided observer.\n     * @param {Object} observer - Observer object\n     * @param {function(record: Object)} observer.onNext - Handle records, one by one.\n     * @param {function(metadata: Object)} observer.onComplete - Handle stream tail, the metadata.\n     * @param {function(error: Object)} observer.onError - Handle errors.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      if (this._error) {\n        observer.onError(this._error);\n        return;\n      }\n\n      if (this._queuedRecords.length > 0) {\n        for (var i = 0; i < this._queuedRecords.length; i++) {\n          observer.onNext(this._queuedRecords[i]);\n        }\n      }\n\n      if (this._tail) {\n        observer.onCompleted(this._tail);\n      }\n\n      this._observer = observer;\n    }\n  }, {\n    key: \"hasFailed\",\n    value: function hasFailed() {\n      return this._hasFailed;\n    }\n  }]);\n  return StreamObserver;\n}();\n\nvar _default = StreamObserver;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}