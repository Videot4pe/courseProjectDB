{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _requestMessage = _interopRequireDefault(require(\"./request-message\"));\n\nvar v1 = _interopRequireWildcard(require(\"./packstream-v1\"));\n\nvar _error = require(\"../error\");\n\nvar _bookmark = _interopRequireDefault(require(\"./bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./tx-config\"));\n\nvar _constants = require(\"./constants\");\n/**\n * Copyright (c) 2002-2019 \"Neo4j,\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar BoltProtocol =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {Connection} connection the connection.\n   * @param {Chunker} chunker the chunker.\n   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.\n   */\n  function BoltProtocol(connection, chunker, disableLosslessIntegers) {\n    (0, _classCallCheck2[\"default\"])(this, BoltProtocol);\n    this._connection = connection;\n    this._packer = this._createPacker(chunker);\n    this._unpacker = this._createUnpacker(disableLosslessIntegers);\n  }\n  /**\n   * Get the packer.\n   * @return {Packer} the protocol's packer.\n   */\n\n\n  (0, _createClass2[\"default\"])(BoltProtocol, [{\n    key: \"packer\",\n    value: function packer() {\n      return this._packer;\n    }\n    /**\n     * Get the unpacker.\n     * @return {Unpacker} the protocol's unpacker.\n     */\n\n  }, {\n    key: \"unpacker\",\n    value: function unpacker() {\n      return this._unpacker;\n    }\n    /**\n     * Transform metadata received in SUCCESS message before it is passed to the handler.\n     * @param {object} metadata the received metadata.\n     * @return {object} transformed metadata.\n     */\n\n  }, {\n    key: \"transformMetadata\",\n    value: function transformMetadata(metadata) {\n      return metadata;\n    }\n    /**\n     * Perform initialization and authentication of the underlying connection.\n     * @param {string} clientName the client name.\n     * @param {object} authToken the authentication token.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(clientName, authToken, observer) {\n      var message = _requestMessage[\"default\"].init(clientName, authToken);\n\n      this._connection.write(message, observer, true);\n    }\n  }, {\n    key: \"prepareToClose\",\n    value: function prepareToClose(observer) {} // no need to notify the database in this protocol version\n\n    /**\n     * Begin an explicit transaction.\n     * @param {Bookmark} bookmark the bookmark.\n     * @param {TxConfig} txConfig the configuration.\n     * @param {string} mode the access mode.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(bookmark, txConfig, mode, observer) {\n      assertTxConfigIsEmpty(txConfig, this._connection, observer);\n\n      var runMessage = _requestMessage[\"default\"].run('BEGIN', bookmark.asBeginTransactionParameters());\n\n      var pullAllMessage = _requestMessage[\"default\"].pullAll();\n\n      this._connection.write(runMessage, observer, false);\n\n      this._connection.write(pullAllMessage, observer, false);\n    }\n    /**\n     * Commit the explicit transaction.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(observer) {\n      // WRITE access mode is used as a place holder here, it has\n      // no effect on behaviour for Bolt V1 & V2\n      this.run('COMMIT', {}, _bookmark[\"default\"].empty(), _txConfig[\"default\"].empty(), _constants.ACCESS_MODE_WRITE, observer);\n    }\n    /**\n     * Rollback the explicit transaction.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"rollbackTransaction\",\n    value: function rollbackTransaction(observer) {\n      // WRITE access mode is used as a place holder here, it has\n      // no effect on behaviour for Bolt V1 & V2\n      this.run('ROLLBACK', {}, _bookmark[\"default\"].empty(), _txConfig[\"default\"].empty(), _constants.ACCESS_MODE_WRITE, observer);\n    }\n    /**\n     * Send a Cypher statement through the underlying connection.\n     * @param {string} statement the cypher statement.\n     * @param {object} parameters the statement parameters.\n     * @param {Bookmark} bookmark the bookmark.\n     * @param {TxConfig} txConfig the auto-commit transaction configuration.\n     * @param {string} mode the access mode.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(statement, parameters, bookmark, txConfig, mode, observer) {\n      // bookmark and mode are ignored in this versioon of the protocol\n      assertTxConfigIsEmpty(txConfig, this._connection, observer);\n\n      var runMessage = _requestMessage[\"default\"].run(statement, parameters);\n\n      var pullAllMessage = _requestMessage[\"default\"].pullAll();\n\n      this._connection.write(runMessage, observer, false);\n\n      this._connection.write(pullAllMessage, observer, true);\n    }\n    /**\n     * Send a RESET through the underlying connection.\n     * @param {StreamObserver} observer the response observer.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset(observer) {\n      var message = _requestMessage[\"default\"].reset();\n\n      this._connection.write(message, observer, true);\n    }\n  }, {\n    key: \"_createPacker\",\n    value: function _createPacker(chunker) {\n      return new v1.Packer(chunker);\n    }\n  }, {\n    key: \"_createUnpacker\",\n    value: function _createUnpacker(disableLosslessIntegers) {\n      return new v1.Unpacker(disableLosslessIntegers);\n    }\n  }]);\n  return BoltProtocol;\n}();\n/**\n * @param {TxConfig} txConfig the auto-commit transaction configuration.\n * @param {Connection} connection the connection.\n * @param {StreamObserver} observer the response observer.\n */\n\n\nexports[\"default\"] = BoltProtocol;\n\nfunction assertTxConfigIsEmpty(txConfig, connection, observer) {\n  if (!txConfig.isEmpty()) {\n    var error = (0, _error.newError)('Driver is connected to the database that does not support transaction configuration. ' + 'Please upgrade to neo4j 3.5.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection\n\n    connection._handleFatalError(error);\n\n    observer.onError(error);\n    throw error;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}